# test case name.  can be used to trigger test case specific code in client,
# e.g., to generate special request sequences or validate intermediate or
# final values of object state. [2017-09-12: added this item]
test_case_name = test1

# number of failures to tolerate.  number of replicas is 2t+1.
t = 3
# number of clients
num_client = 2
# client timeout, in milliseconds.  if timer expires, resend request 
# to all replicas, as described in section 3.3.

client_timeout = 3000
# timeout, in milliseconds, for head and non-head servers, respectively:
# if timer expires, send reconfiguration request to Olympus, as described 
# in section 3.3.
head_timeout = 2000
nonhead_timeout = 1000

checkpoint_limit = 3

hosts = localhost; 192.168.0.3; 192.168.0.4
client_hosts = 1; 0; 0
replica_hosts = 0; 1; 2

# CLIENT WORKLOAD
workload[0] = put('movie','star'); append('movie',' wars'); put('hero', 'Ben Affleck'); get('movie'); append('hero', ': Batman'); put('actress', 'Gal'); append('actress', ' Gadot')
workload[1] = put('dude','michael'); append('dude',' scott'); put('love', 'pam'); get('dude'); append('love', ' & Jim'); put('Dwight', 'Shrute'); append('Dwight', ' Angela')

failures[0,3] = checkpoint(2), crash()

#####################################################################################################################################################
# test case name.  can be used to trigger test case specific code in client,
# e.g., to generate special request sequences or validate intermediate or
# final values of object state. [2017-09-12: added this item]
test_case_name = test2

# number of failures to tolerate.  number of replicas is 2t+1.
t = 2
# number of clients
num_client = 4 
# client timeout, in milliseconds.  if timer expires, resend request 
# to all replicas, as described in section 3.3.
client_timeout = 3000
# timeout, in milliseconds, for head and non-head servers, respectively:
# if timer expires, send reconfiguration request to Olympus, as described 
# in section 3.3.
head_timeout = 1000
nonhead_timeout = 2000
checkpoint_limit = 7

# MAPPING OF PROCESSES TO HOSTS
# to simplify changing the hosts, we first specify a semicolon-separated
# list of hosts, and then use 0-based indices into that list to specify the
# host on which each process runs.
# list of hosts used in this scenario
hosts = localhost; 192.168.0.3; 192.168.0.4
# host on which each client runs.  in this example, client 0 runs 
# on host 1, clients 1 and 2 run on host 0.
client_hosts = 1; 0; 0
# host on which each replica runs.  same in all configurations.
replica_hosts = 0; 1; 2

# CLIENT WORKLOAD
workload[0] = slice('start', '2:10'); append('start', 'cramp'); put('firer', 'amplitude'); slice('firer', '8:0'); append('start', 'jaw'); slice('firer', '4:7'); put('whirls', 'courts'); get('whirls'); slice('whirls', '9:2'); get('firer'); put('meat', 'steamers'); slice('start', '6:5'); append('firer', 'crops'); get('meat'); get('meat'); append('firer', 'commissions'); slice('whirls', '3:5'); get('whirls'); get('firer'); get('whirls')
workload[1] = get('start'); get('start'); get('start'); append('start', 'downgrades'); put('lever', 'hillside'); get('start'); put('shaft', 'neutron'); put('stress', 'sunlight'); get('shaft'); append('shaft', 'validations'); slice('lever', '9:10'); append('shaft', 'midnight'); slice('stress', '0:0'); slice('lever', '7:8'); slice('lever', '5:1'); slice('lever', '8:9'); append('lever', 'checker'); append('lever', 'merchant'); put('skill', 'bed'); get('start')
workload[2] = put('claws', 'polices'); append('start', 'businesses'); get('claws'); get('start'); get('claws'); get('start'); append('claws', 'percentage'); put('coats', 'acts'); get('start'); append('coats', 'coughs'); put('proficiency', 'turnarounds'); append('start', 'fabrication'); append('start', 'till'); slice('coats', '3:8'); append('start', 'brains'); append('start', 'bunches'); slice('coats', '2:8'); append('proficiency', 'points'); put('assembly', 'abbreviations'); slice('start', '2:0')
workload[3] = slice('start', '3:6'); put('watchstanding', 'rules'); slice('watchstanding', '3:8'); append('watchstanding', 'character'); put('capabilities', 'filler'); append('capabilities', 'sidewalk'); append('watchstanding', 'night'); append('start', 'chemicals'); append('watchstanding', 'capacitor'); put('march', 'multiplications'); put('matter', 'kettles'); put('length', 'coordinates'); append('matter', 'breezes'); put('beam', 'holder'); get('length'); slice('capabilities', '8:1'); slice('length', '4:7'); put('blankets', 'calibration'); append('blankets', 'finger'); get('blankets')

# FAILURE SCENARIO
# failures(c,r) is the failure scenario for replica r in configuration c.
# configurations are numbered starting with 0.  replicas are numbered by
# position in the chain, starting from 0.  replicas without a specified
# failure scenario are failure-free.
# 0th config and 0th replica, the second client sends a message with request number 1, and head decides to crash

failures[0,3] = shuttle(0,2), drop_result_stmt()



#####################################################################################################################################################

# test case name.  can be used to trigger test case specific code in client,
# e.g., to generate special request sequences or validate intermediate or
# final values of object state. [2017-09-12: added this item]
test_case_name = test3

# number of failures to tolerate.  number of replicas is 2t+1.
t = 3
# number of clients
num_client = 1
# client timeout, in milliseconds.  if timer expires, resend request 
# to all replicas, as described in section 3.3.
client_timeout = 3000
# timeout, in milliseconds, for head and non-head servers, respectively:
# if timer expires, send reconfiguration request to Olympus, as described 
# in section 3.3.
head_timeout = 1000
nonhead_timeout = 2000

checkpoint_limit = 7
# MAPPING OF PROCESSES TO HOSTS
# to simplify changing the hosts, we first specify a semicolon-separated
# list of hosts, and then use 0-based indices into that list to specify the
# host on which each process runs.
# list of hosts used in this scenario
hosts = localhost; 192.168.0.3; 192.168.0.4
# host on which each client runs.  in this example, client 0 runs 
# on host 1, clients 1 and 2 run on host 0.
client_hosts = 1; 0; 0
# host on which each replica runs.  same in all configurations.
replica_hosts = 0; 1; 2

# CLIENT WORKLOAD
workload[0] = slice('start', '4:0'); slice('start', '2:5'); append('start', 'correlation'); slice('start', '3:9'); get('start'); get('start'); slice('start', '1:5'); get('start'); slice('start', '1:2'); get('start') 
# workload[1] = append('start', 'rakes'); append('start', 'meanings'); get('start'); put('evaluations', 'nausea'); append('evaluations', 'walk'); slice('evaluations', '3:1'); slice('start', '9:5'); put('shoe', 'moonlight'); get('evaluations'); slice('shoe', '2:0')
# workload[2] = append('start', 'exposures'); slice('start', '3:9'); append('start', 'vol.'); append('start', 'dam'); slice('start', '3:4'); get('start'); append('start', 'pitches'); put('gyroscopes', 'point'); slice('start', '1:5'); append('start', 'petition')
# workload[3] = append('start', 'pipe'); get('start'); put('punches', 'handful'); put('pick', 'maples'); slice('pick', '4:2'); get('start'); append('start', 'wardroom'); get('punches'); slice('pick', '9:4'); get('start')
# workload[4] = get('start'); slice('start', '8:10'); get('start'); put('blocks', 'street'); get('blocks'); put('substance', 'patch'); slice('start', '9:4'); append('start', 'threats'); put('reservists', 'hazard'); slice('start', '9:5')
# workload[5] = put('arts', 'milks'); append('start', 'drive'); get('start'); append('arts', 'ending'); put('relocations', 'bump'); put('blueprint', 'guard'); get('blueprint'); append('blueprint', 'cry'); get('start'); slice('relocations', '9:2')
# workload[6] = get('start'); append('start', 'taxes'); put('crowns', 'electrons'); get('crowns'); append('crowns', 'grinder'); get('start'); get('start'); append('crowns', 'burns'); append('start', 'parentheses'); put('turn', 'increment')
# workload[7] = append('start', 'berths'); slice('start', '5:7'); get('start'); put('memorandum', 'tensions'); get('start'); slice('memorandum', '1:2'); put('implantation', 'airships'); slice('implantation', '6:3'); put('lands', 'torque'); put('windlasses', 'carload')

# FAILURE SCENARIO
# failures(c,r) is the failure scenario for replica r in configuration c.
# configurations are numbered starting with 0.  replicas are numbered by
# position in the chain, starting from 0.  replicas without a specified
# failure scenario are failure-free.
# 0th config and 0th replica, the second client sends a message with request number 1, and head decides to crash

failures[0,6] = shuttle(0,1), crash()
failures[0,0] = forwarded_request(0,2), sleep(200000)
# shuttle(0,3), drop_result_stmt()
# failures[0,1] = result_shuttle(2,1),change_result()
#failures[0,2] = shuttle(0,5), drop_result_stmt()

# 0the config and 2nd replica, 0the client sends message req1 to 2nd replica... 
# failures[1,2] = result_shuttle(0,1),drop();shuttle(1,3),omit_send()

#TEST VALUES
 
 
 
#####################################################################################################################################################
 
 
 # test case name.  can be used to trigger test case specific code in client,
# e.g., to generate special request sequences or validate intermediate or
# final values of object state. [2017-09-12: added this item]
test_case_name = test4

# number of failures to tolerate.  number of replicas is 2t+1.
t = 3
# number of clients
num_client = 1
# client timeout, in milliseconds.  if timer expires, resend request 
# to all replicas, as described in section 3.3.
client_timeout = 3000
# timeout, in milliseconds, for head and non-head servers, respectively:
# if timer expires, send reconfiguration request to Olympus, as described 
# in section 3.3.
head_timeout = 1000
nonhead_timeout = 2000
checkpoint_limit = 4

# MAPPING OF PROCESSES TO HOSTS
# to simplify changing the hosts, we first specify a semicolon-separated
# list of hosts, and then use 0-based indices into that list to specify the
# host on which each process runs.
# list of hosts used in this scenario
hosts = localhost; 192.168.0.3; 192.168.0.4
# host on which each client runs.  in this example, client 0 runs 
# on host 1, clients 1 and 2 run on host 0.
client_hosts = 1; 0; 0
# host on which each replica runs.  same in all configurations.
replica_hosts = 0; 1; 2

# CLIENT WORKLOAD


workload[0] = put('movie','star'); append('movie',' wars'); put('hero', 'Ben Affleck'); get('movie'); append('hero', ': Batman'); put('actress', 'Gal'); append('actress', ' Gadot'); put('justice league','superman'); append('justice league','& wonder woman'); append('justice league',' & Batman')
# FAILURE SCENARIO
# failures(c,r) is the failure scenario for replica r in configuration c.
# configurations are numbered starting with 0.  replicas are numbered by
# position in the chain, starting from 0.  replicas without a specified
# failure scenario are failure-free.
# 0th config and 0th replica, the second client sends a message with request number 1, and head decides to crash

# failures[0,0] = result_shuttle(0,1), change_result()
# shuttle(0,3), drop_result_stmt()
# failures[0,1] = result_shuttle(2,1),change_result()
#failures[0,2] = shuttle(0,5), drop_result_stmt()

# 0the config and 2nd replica, 0the client sends message req1 to 2nd replica... 
# failures[1,2] = result_shuttle(0,1),drop();shuttle(1,3),omit_send()

failures[0,3] = completed_checkpoint(1), drop()
 
 
#####################################################################################################################################################
 
 
 
 # test case name.  can be used to trigger test case specific code in client,
# e.g., to generate special request sequences or validate intermediate or
# final values of object state. [2017-09-12: added this item]
test_case_name = test5

# number of failures to tolerate.  number of replicas is 2t+1.
t = 3
# number of clients
num_client = 1
# client timeout, in milliseconds.  if timer expires, resend request 
# to all replicas, as described in section 3.3.
client_timeout = 4000
# timeout, in milliseconds, for head and non-head servers, respectively:
# if timer expires, send reconfiguration request to Olympus, as described 
# in section 3.3.
head_timeout = 1000
nonhead_timeout = 2000
checkpoint_limit = 4

# MAPPING OF PROCESSES TO HOSTS
# to simplify changing the hosts, we first specify a semicolon-separated
# list of hosts, and then use 0-based indices into that list to specify the
# host on which each process runs.
# list of hosts used in this scenario
hosts = localhost; 192.168.0.3; 192.168.0.4
# host on which each client runs.  in this example, client 0 runs 
# on host 1, clients 1 and 2 run on host 0.
client_hosts = 1; 0; 0
# host on which each replica runs.  same in all configurations.
replica_hosts = 0; 1; 2

# CLIENT WORKLOAD
workload[0] = put('movie','star'); append('movie',' wars'); put('hero', 'Ben Affleck'); get('movie'); append('hero', ': Batman'); put('actress', 'Gal'); append('actress', ' Gadot'); put('justice league','superman'); append('justice league','& wonder woman'); append('justice league','& Batman & Flash'); put('Marvel','Avengers')
# FAILURE SCENARIO
# failures(c,r) is the failure scenario for replica r in configuration c.
# configurations are numbered starting with 0.  replicas are numbered by
# position in the chain, starting from 0.  replicas without a specified
# failure scenario are failure-free.
# 0th config and 0th replica, the second client sends a message with request number 1, and head decides to crash

failures[0,2] = shuttle(0,3), crash()
failures[1,3] = new_configuration(0), extra_op()


################################################################################################# 
 
 
 # test case name.  can be used to trigger test case specific code in client,
# e.g., to generate special request sequences or validate intermediate or
# final values of object state. [2017-09-12: added this item]
test_case_name = test6

# number of failures to tolerate.  number of replicas is 2t+1.
t = 3
# number of clients
num_client = 1
# client timeout, in milliseconds.  if timer expires, resend request 
# to all replicas, as described in section 3.3.
client_timeout = 2000
# timeout, in milliseconds, for head and non-head servers, respectively:
# if timer expires, send reconfiguration request to Olympus, as described 
# in section 3.3.
head_timeout = 500
nonhead_timeout = 1000

# MAPPING OF PROCESSES TO HOSTS
# to simplify changing the hosts, we first specify a semicolon-separated
# list of hosts, and then use 0-based indices into that list to specify the
# host on which each process runs.
# list of hosts used in this scenario
hosts = localhost; 192.168.0.3; 192.168.0.4
# host on which each client runs.  in this example, client 0 runs 
# on host 1, clients 1 and 2 run on host 0.
client_hosts = 1; 0; 0
# host on which each replica runs.  same in all configurations.
replica_hosts = 0; 1; 2

# CLIENT WORKLOAD
workload[0] = put('movie','star'); append('movie',' wars'); put('hero', 'Ben Affleck'); get('movie'); append('hero', ': Batman'); put('actress', 'Gal'); append('actress', ' Gadot'); put('justice league','superman'); append('justice league','| wonder woman'); append('justice league','| Batman | Flash'); put('Marvel', 'bad movies'); append('actress',': Married'); put('superman', 'Henry Cavill')

# FAILURE SCENARIO
# failures(c,r) is the failure scenario for replica r in configuration c.
# configurations are numbered starting with 0.  replicas are numbered by
# position in the chain, starting from 0.  replicas without a specified
# failure scenario are failure-free.
# 0th config and 0th replica, the second client sends a message with request number 1, and head decides to crash

# failures[0,0] = result_shuttle(0,1), change_result()
# shuttle(0,3), drop_result_stmt()
# failures[0,1] = result_shuttle(2,1),change_result()
failures[0,3] = result_shuttle(0,1), change_result()
failures[1,0] = new_configuration(0), increment_slot()

# 0the config and 2nd replica, 0the client sends message req1 to 2nd replica... 
# failures[1,2] = result_shuttle(0,1),drop();shuttle(1,3),omit_send()

#TEST VALUES
########################################################################################## 
 
 
 # test case name.  can be used to trigger test case specific code in client,
# e.g., to generate special request sequences or validate intermediate or
# final values of object state. [2017-09-12: added this item]
test_case_name = test7

# number of failures to tolerate.  number of replicas is 2t+1.
t = 3
# number of clients
num_client = 1
# client timeout, in milliseconds.  if timer expires, resend request 
# to all replicas, as described in section 3.3.
client_timeout = 3000
# timeout, in milliseconds, for head and non-head servers, respectively:
# if timer expires, send reconfiguration request to Olympus, as described 
# in section 3.3.
head_timeout = 1000
nonhead_timeout = 2000

# MAPPING OF PROCESSES TO HOSTS
# to simplify changing the hosts, we first specify a semicolon-separated
# list of hosts, and then use 0-based indices into that list to specify the
# host on which each process runs.
# list of hosts used in this scenario
hosts = localhost; 192.168.0.3; 192.168.0.4
# host on which each client runs.  in this example, client 0 runs 
# on host 1, clients 1 and 2 run on host 0.
client_hosts = 1; 0; 0
# host on which each replica runs.  same in all configurations.
replica_hosts = 0; 1; 2

# CLIENT WORKLOAD
workload[0] = put('movie','star'); append('movie',' wars'); put('hero', 'Ben Affleck'); get('movie'); append('hero', ': Batman'); put('actress', 'Gal'); append('actress', ' Gadot'); put('justice league','superman'); append('justice league','| wonder woman'); append('justice league','| Batman | Flash'); put('Marvel', 'bad movies'); append('actress',': Married'); put('spiderman', 'peter parker'); append('water', 'bottle')

# FAILURE SCENARIO
# failures(c,r) is the failure scenario for replica r in configuration c.
# configurations are numbered starting with 0.  replicas are numbered by
# position in the chain, starting from 0.  replicas without a specified
# failure scenario are failure-free.
# 0th config and 0th replica, the second client sends a message with request number 1, and head decides to crash

failures[0,3] = shuttle(0,4), sleep(20000)
failures[0,2] = wedge_request(0), truncate_history(2) 





##################################################################################################
 # test case name.  can be used to trigger test case specific code in client,
# e.g., to generate special request sequences or validate intermediate or
# final values of object state. [2017-09-12: added this item]
test_case_name = test8

# number of failures to tolerate.  number of replicas is 2t+1.
t = 3
# number of clients
num_client = 1
# client timeout, in milliseconds.  if timer expires, resend request 
# to all replicas, as described in section 3.3.
client_timeout = 3000
# timeout, in milliseconds, for head and non-head servers, respectively:
# if timer expires, send reconfiguration request to Olympus, as described 
# in section 3.3.
head_timeout = 2000
nonhead_timeout = 1000

# MAPPING OF PROCESSES TO HOSTS
# to simplify changing the hosts, we first specify a semicolon-separated
# list of hosts, and then use 0-based indices into that list to specify the
# host on which each process runs.
# list of hosts used in this scenario
hosts = localhost; 192.168.0.3; 192.168.0.4
# host on which each client runs.  in this example, client 0 runs 
# on host 1, clients 1 and 2 run on host 0.
client_hosts = 1; 0; 0
# host on which each replica runs.  same in all configurations.
replica_hosts = 0; 1; 2

# CLIENT WORKLOAD
workload[0] = pseudorandom(190,50)

# FAILURES#
failures[0,3] = shuttle(0,5), drop_checkpt_stmts() 
failures[1,3] = checkpoint(2), invalid_order_sig()
failures[2,2] = result_shuttle(0,2), invalid_result_sig()
failures[2,0] = catch_up(0), crash()







##################################################################################################
 # test case name.  can be used to trigger test case specific code in client,
# e.g., to generate special request sequences or validate intermediate or
# final values of object state. [2017-09-12: added this item]
test_case_name = test9

# number of failures to tolerate.  number of replicas is 2t+1.
t = 2
# number of clients
num_client = 1
# client timeout, in milliseconds.  if timer expires, resend request 
# to all replicas, as described in section 3.3.
client_timeout = 3000
# timeout, in milliseconds, for head and non-head servers, respectively:
# if timer expires, send reconfiguration request to Olympus, as described 
# in section 3.3.
head_timeout = 2000
nonhead_timeout = 1000

# MAPPING OF PROCESSES TO HOSTS
# to simplify changing the hosts, we first specify a semicolon-separated
# list of hosts, and then use 0-based indices into that list to specify the
# host on which each process runs.
# list of hosts used in this scenario
hosts = localhost; 192.168.0.3; 192.168.0.4
# host on which each client runs.  in this example, client 0 runs 
# on host 1, clients 1 and 2 run on host 0.
client_hosts = 1; 0; 0
# host on which each replica runs.  same in all configurations.
replica_hosts = 0; 1; 2

# CLIENT WORKLOAD
workload[0] = pseudorandom(190,100)

# FAILURES
failures[0,4] = shuttle(0,90), drop(); get_running_state(0), sleep(700)
failures[0,2] = get_running_state(0), sleep(200)
failures[0,0] = get_running_state(0), sleep(300)
failures[0,3] = get_running_state(0), sleep(400)



# performance test: 3 clients each send 300 pseudorandom operations.  2017-11-12
test_case_name = perform900

# expected outcome: 
# no crashes, exceptions, etc.  
# tail sends 900 result messages to clients.  check for this in the log.
#  Sample commands to use, assuming tail's log is in tail.log and log entry
#  for sending a result message contains the string "result_message":
#  linux, mac os: grep --count result_message tail.log
#  windows (in PowerShell): find /C `"result_message`" tail.log

# number of failures to tolerate.  number of replicas is 2t+1.
t = 2
# number of clients
num_client = 3
# client timeout, in milliseconds. 
client_timeout = 3000
# timeout, in milliseconds, for head and non-head servers, respectively
head_timeout = 3000
nonhead_timeout = 3000

# CLIENT WORKLOAD
workload[0] = pseudorandom(190,300)
workload[1] = pseudorandom(191,300)
workload[2] = pseudorandom(192,300)

# FAILURE SCENARIO
# no failures
