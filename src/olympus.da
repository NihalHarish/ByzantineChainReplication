from Crypto.PublicKey import RSA
from Crypto import Random
from Crypto.Hash import SHA256
import uuid
import re
import logging
from replica import Replica
import message_type
import config_handler
import os
import random
import json
import random
GET_CONFIG = 'get_config'
SEND_CONFIG = 'take_config'


class Olympus(process):

    def setup(client_dict: instance, client_list: instance,
              client_keys: instace, test_case: str, crypt_key: instance):
        self.public_key = None
        self.replicas_key_pairs = {}
        self.replicas_data = {}
        self.replica_list = []
        self.head_node = None
        self.client_dict = client_dict
        self.client_list = client_list
        self.client_public_keys = client_keys
        self.config = {}
        self.test_case = test_case
        self.tail_node = None
        self.crypt_key = crypt_key
        self.wedge_responses = []
        self.t = None
        self.hashes_for_reference = []
        self.replica_public_keys = {}
        self.replica_map = {}
        self.lock = False

    def generate_replica_key_pair(replica_id):
        random_generator = Random.new().read
        key = RSA.generate(1024, random_generator)
        public_key = key.publickey().exportKey()
        self.replicas_key_pairs[replica_id] = public_key
        self.replica_public_keys[replica_id] = RSA.importKey(public_key)
        return (key, self.replicas_key_pairs)

    def sign_message():
        nonce = random.randint(1, 1000)
        message = self.crypt_key.sign(nonce, '')
        return (message, nonce)

    def init_replicas(number):
        logging.info("Staring replica init for t = " + str(number))
        replicas = list(new(Replica, num=number))
        replica_ids = [uuid.uuid4().hex for replica in replicas]
        keys = [generate_replica_key_pair(replica_id)
                for replica_id in replica_ids]
        failure = self.config['failures']
        print(failure)
        replica_fail = {}
        for i in failure:
            replica_index = int(i['replica_number'])
            # we will have to construct a message as follows: (trigger_msg,
            # from_which_client, msg_number, failure_action)
            for failure_operation in i['operations']:
                failure_trigger, failure_action = failure_operation
                failure_trigger_msg = re.search(r'\w+',
                                                failure_trigger).group()
                failure_addresses_regex = re.search(r'(\d+),(\d+)',
                                                    failure_trigger)
                failure_from = int(failure_addresses_regex.group(1))
                failure_message_number = int(failure_addresses_regex.group(2))

                failure_list = [
                    failure_trigger_msg,
                    failure_from,
                    failure_message_number,
                    failure_action]  # False, means dont execute now
                if replica_index not in replica_fail:
                    replica_fail[replica_index] = [failure_list]
                else:
                    replica_fail[replica_index].append(failure_list)

        print(replica_fail)

        head_replica_id = replica_ids[0]
        for i, replica in enumerate(replicas):
            replica_id = replica_ids[i]
            replica_map[replica_id] = replica
            isHead = True if i == 0 else False
            isTail = True if i == (len(replicas) - 1) else False

            prev_r = None if isHead else replicas[i - 1]
            next_r = None if isTail else replicas[i + 1]

            key, keychain = keys[i]
            if isHead:
                self.head_node = replica
                timeout_val = int(self.config['head_timeout'])
            if isTail:
                self.tail_node = replica
                timeout_val = int(self.config['nonhead_timeout'])

            if i in replica_fail:
                setup(
                    {replica},
                    (isHead,
                     isTail,
                     replica_id,
                     prev_r,
                     next_r,
                     key,
                     keychain,
                     self.client_list,
                     self.head_node,
                     self.client_dict,
                     timeout_val,
                     self.client_public_keys,
                     replica_fail[i],
                     head_replica_id,
                     test_case,
                     self
                     ))
            else:
                setup(
                    {replica},
                    (isHead,
                     isTail,
                     replica_id,
                     prev_r,
                     next_r,
                     key,
                     keychain,
                     self.client_list,
                     self.head_node,
                     self.client_dict,
                     timeout_val,
                     self.client_public_keys,
                     [],
                     head_replica_id,
                     test_case,
                     self
                     ))

        start(replicas)
        logging.info("Replica init for t = " + str(number) + " is complete")
        self.replica_list = replicas

    def parse_workload(workload):
        match = re.match(r'^[^\(]+', workload).group()
        if match == 'pseudorandom':
            seed, size = re.search(
                r'\(([^)]+)\)', workload).group()[1:-1].replace("'", "").split(',')
            seed = int(seed)
            size = int(size)
            workload = config_handler.pseudorandom(seed, size)
            print('Workload: ', workload)
        return workload

    def craft_client_config(client):
        print('crafting clients config')
        client_index = self.client_list.index(client)
        config = config_handler.load_config()[test_case]
        client_config = {}
        client_config['client_timeout'] = config['client_timeout']
        client_config['workload'] = parse_workload(
            self.config['workload'][client_index])
        client_config['replica_list'] = self.replica_list
        client_config['head_node'] = self.head_node
        client_config['tail_node'] = self.tail_node
        client_config['replica_keys'] = self.replicas_key_pairs
        client_config['replicas'] = self.replica_list
        client_config['t'] = config['t']
        client_config['failures'] = config['failures']
        print('done crafting clients config!')
        return client_config

    def validate_client(message):
        signature, nonce, client_id = message
        public_key = self.client_public_keys[client_id]
        if public_key.verify(nonce, signature):
            return True
        return False

    def receive(msg=('get_config', signed_message), from_=client):
        print("Olympus has received config request from client: ", client)
        logging.info(
            "Olympus has received config request from client: " +
            str(client))
        if validate_client(signed_message):
            config = craft_client_config(client)
            print('Will be sending config to ', str(client))
            signature = sign_message()
            send((SEND_CONFIG, config, signature), to=client)
            logging.info("Olympus has validated client: " + str(client))
            logging.info("Olympus has sent config to client: " + str(client))

    def receive(msg=('reconfigure-request'), from_=anyone):
        print ('got reconfigure request from ', anyone)
        for repl in replica_list:
            send(('wedge-request'), to=repl)
        # send wedge request to all the replicas


    def validate_wedge_response(signed_wedge_statement):
       signature, statement, replica_id = signed_wedge_statement
       hashed_statement = SHA256.new(
           json.dumps(statement). encode('utf-8')).digest()
       public_key = self.replica_public_keys[replica_id]
       if public_key.verify(hashed_statement, signature):
           return True
       else:
           return False  # The result_statement has been changed because of failure injection

    def check_all_history_consistent(quorum_list):
        '''
            quorum list will contain [(signature, wedge_statement, replica_id), ...]
            wedge_statement contains (checkpoint, history)
            for now we are interested only in history
        '''
        temp_history = {}
        order_proof_length_map = {}
        for replica_statement in quorum_list:
            # TODO: decrypt the wedge statement
            _, wedge_statement, _ = replica_statement
            checkpoint, history = wedge_statement
            for history_statement in history:
                # TODO: decrypt the order proof 
                slot, operation, order_proof = history_statement
                if slot not in temp_history:
                    temp_history[slot] = operation
                    order_proof_length_map[slot] = len(order_proof)
                else:
                    order_proof_length_map[slot] = max(order_proof_length_map[slot],\
                            len(order_proof))
                    if operation != temp_history[slot]:
                        return False
        # checking if all order proofs have atleast size t + 1
        print(2, order_proof_length_map)
        for sizes_of_order_proof in order_proof_length_map.values():
            if sizes_of_order_proof < self.config['t'] + 1:
                return False
        return True

    def filter_longest_history(selected_quorum):
        max_history = None
        max_slot_number = -1
        count_max_slot_number = 0
        for replica_statement in selected_quorum:
            _, wedge_statement, _ = replica_statement
            checkpoint, history = wedge_statement
            if history[-1] is not None:
                if history[-1][0] > max_slot_number:
                    max_history = history
                    max_slot_number = history[-1][0]
        return list(map(lambda x: (x[0], x[1]), max_history))  # return only slot and operation

    def history_difference(big_history, replica_history, replica_checkpoint):
        catch_up = []
        checkpoint_data = None
        if replica_checkpoint is not None:
            checkpoint_data = map(lambda x: x[1][1], replica_checkpoint)
        print('checkpoint ', list(checkpoint_data))
        for hist in big_history:
            slot, operation = hist
            if (slot, operation) not in replica_history:
                if checkpoint_data is None:
                    catch_up.append((slot, operation))
                elif slot > checkpoint_data[0]:
                    catch_up.append((slot, operation))
        return catch_up

    def select_quorum():
        if self.lock:
            return
        else:
            self.lock = True
        print('selecting the freaking quorum ')
        selected_quorum = random.sample(wedge_responses, self.config['t'] + 1)
        print('selected quorum ppl', list(map(lambda x: replica_map[x[-1]], selected_quorum)),\
                list(map(lambda x: replica_map[x[-1]], wedge_responses)))
        if check_all_history_consistent(selected_quorum):
            longest_history = filter_longest_history(selected_quorum)
            print('the longest history is ', longest_history)
            for replica_statement in selected_quorum:
                _, wedge_statement, replica_id = replica_statement
                checkpoint, history = wedge_statement
                replica_history = map(lambda x: (x[0], x[1]), history)  # extract only slot and operation
                catch_up_operations = history_difference(longest_history, replica_history, checkpoint)
                print('sending catchup to ', replica_map[replica_id])
                print('catchup payload ', catch_up_operations)
                send(('catchup-request', catch_up_operations), to= replica_map[replica_id])
        else:
            print('history is not consistent')
            self.lock = False
            select_quorum()



    def receive(msg=('wedge-response', wedge_statement), from_=some_replica):
        # validate the wedge response from the replica
        if validate_wedge_response(wedge_statement):
            wedge_responses.append(wedge_statement)
            if len(wedge_responses) == 2*self.config['t'] + 1:  # TODO: BLUNDER
                select_quorum()


    def validate_caughtup_response(signed_running_hash):
       signature, statement, replica_id = signed_running_hash
       hashed_statement = SHA256.new(
           json.dumps(statement). encode('utf-8')).digest()
       public_key = self.replica_public_keys[replica_id]
       if public_key.verify(hashed_statement, signature):
           return True
       else:
           return False  # The result_statement has been changed because of failure injecti


    def generate_signature():
        nonce = random.randint(1, 1000)
        message = self.crypt_key.sign(nonce, '')
        return (message, nonce, client_id)

    def receive(msg=('caughtup-response', signed_running_hash), from_=rep):
        if validate_caughtup_response(signed_running_hash):
            _, statement, replica_id = signed_running_hash
            if len(self.hashes_for_reference) == 0:
                self.hashes_for_reference.append((statement, replica_id))
            elif self.hashes_for_reference[0][0] != statement:
                print('dude the hashes are not consistent ', self.hashes_for_reference, statement, rep)
                self.hashes_for_reference = []
                self.lock = False
                select_quorum()
            else:
                self.hashes_for_reference.append((statement, replica_id))
            if len(self.hashes_for_reference) == self.config['t'] + 1:
                print('received hash {0} from {1}'.format(self.hashes_for_reference, replica_id))
                random_replica = random.choice(self.hashes_for_reference)[1]
                # signature = generate_signature()
                send(('get-running-state'), to=replica_map[random_replica])


    def receive(msg=('running-state', state), from_=olympus):
        print('received running state ', state)
        hashed_statement = SHA256.new(
                json.dumps(state). encode('utf-8')).hexdigest()
        random_hash_from_reference = random.choice(self.hashes_for_reference)[0]
        print(hashed_statement, random_hash_from_reference)
        if hashed_statement == random_hash_from_reference:
            print('This is a freaking success')


    # def init_logger():
    #     logging_directory = os.path.join(os.path.dirname(\
    #             os.path.abspath(__file__)), \
    #             '../logs/{0}'.format(test_case))
    #     logging.basicConfig(filename=os.path.join(logging_directory, \
    #             'olympus.log'), filemode='w', level=logging.INFO)
    #     logging.info("Olympus has sent config to client: " + str(client))

    def init_logger():
        logging_directory = os.path.join(os.path.dirname(
            os.path.abspath(__file__)),
            '../logs/{0}'.format(test_case))
        logging.basicConfig(
            filename=os.path.join(
                logging_directory,
                'olympus.log'),
            filemode='w',
            level=logging.INFO)

    def run():
        import sys
        sys.setrecursionlimit(1000000000)
        init_logger()
        logging.info("Olympus has started")
        self.config = config_handler.load_config()[self.test_case]
        t = self.config['t']
        t = 2 * t + 1
        print("T: ", t)
        init_replicas(t)
        print("Olympus Running")
        await(False)
