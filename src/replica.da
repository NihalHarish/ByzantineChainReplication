import uuid, json
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA
from Crypto import Random

# Replica States
REPLICA_PENDING = 'PENDING'
REPLICA_ACTIVE = 'ACTIVE'
REPLICA_IMMUTABLE = 'IMMUTABLE'


# Shuttle message keys
SHUTTLE_RESULT_PROOF = 'result_proof'
SHUTTLE_ORDER_PROOF = 'order_proof'
SHUTTLE_SLOT = 'slot'
SHUTTLE_OPERATION = 'operation'
SHUTTLE_CHECKSUM = 'checksum'
SHUTTLE_CLIENT_ID = 'client_id'
SHUTTLE = 'shuttle'

class Replica(process):
    def setup(isHead: bool, isTail: bool, unique_id: str, prev_replica: Replica, next_replica: Replica, key: instance, keychain: dict):
        self.uuid = unique_id
        self.running_state = {}
        self.history = []
        self.result_proof = []
        self.order_proof = []

        self.mode = REPLICA_ACTIVE
        self.prev_replica = prev_replica
        self.next_replica = next_replica
        self.public_keys = {}
        self.private_key = None
        self.result_shuttle_cache = {}
        self.checkpoint_proof_cache = {}
        self.isHead = isHead
        self.isTail = isTail
        self.current_slot = 0
        self.config_number = 1
        self.retransmission = []
        self.waiting_for_result_proof = {}
        self.passport = key
        _build_key_chain(keychain)

    def _build_key_chain(keychain):
        for replica_id, public_key in keychain.items():
            self.public_keys[replica_id] = RSA.importKey(public_key)

    '''
        Dictionary Operations

    '''

    def _put(params):
        key, value = params
        self.running_state[key] = value

    def _append(params):
        key, new_value = params
        if key in self.running_state:
            early_value = self.running_state[key]
            self.running_state[key] = early_value + new_value

    def _get(key):
        if key in self.running_state:
            return self.running_state[key]
        return None

    def _slice(params):
        key, value = params
        if key in self.running_state:
            start, end = map(int, value.split(':'))
            early_value = self.running_state[key]
            self.running_state[key] = early_value[start: end]

    def run():
        #test_dict_object()
        if self.isHead:
            handle_operation()
        await(False)

    def update_current_slot_number():
        self.current_slot += 1

    def compute_running_state_hash():
        running_state_json = json.dumps(self.running_state).encode('utf-8')
        return SHA256.new(running_state_json).hexdigest()

    def generate_result_statement(result_hash):
        statement = json.dumps(('result', result_hash)).encode('utf-8')
        return statement

    def sign_result_statement(result_statement):
        signature = self.passport.sign(result_statement, '')
        return signature

    def add_to_result_proof(signed_result_proof):
        self.result_proof.append(signed_result_proof)


    def generate_order_statement(slot, operation):
        order_statement = json.dumps(('order', slot, operation)).encode('utf-8')
        return order_statement

    def sign_order_statement(order_statement):
        signature = self.passport.sign(order_statement, '')
        return signature

    def add_to_order_proof(signed_order_statement):
        self.order_proof.append(signed_order_statement)

    def generate_history_statement(slot, operation, order_proof):  # TODO
        history_statement = json.dumps((slot, operation, order_proof)).encode('utf-8')
        return history_statement

    def add_to_history(history_statement):
        self.history.append(history_statement)

    def handle_operation():
        update_current_slot_number()
        _put(('movie', 'Bangalore Days'))
        result_hash = compute_running_state_hash()
        result_statement = generate_result_statement(result_hash)
        signed_result_statement = sign_result_statement(result_statement)
        add_to_result_proof(signed_result_statement)

        slot = self.current_slot
        operation = 'put(\'movie\':\'Bangalore Days\')'
        order_statement = generate_order_statement(slot, operation)
        signed_order_statement = sign_order_statement(order_statement)
        add_to_order_proof(signed_order_statement)

        history_statement = generate_history_statement(slot, operation, self.order_proof)  # TODO: add replica_id and config number
        add_to_history(history_statement)


        checksum = SHA256.new(json.dumps((1,1)).encode('utf-8')).hexdigest()  # TODO: client request checksum
        waiting_for_result_proof[checksum] = True

        shuttle_message = generate_shuttle_message(self.result_proof, self.order_proof, slot, operation)
        print('sending shuttle message to ', next_replica)
        send(('shuttle', shuttle_message), to=next_replica)
        await(False) #  TODO: This needs to wait till it receives a complete result proof from its next replica


    def check_order_proof_validity(order_proof_list):
        print('Yayy, checking order proof validity ', order_proof_list)
        pass

    def receive(msg=(SHUTTLE, payload), from_=prev_replica):
        shuttle_msg = payload
        print(shuttle_msg)
        if self.current_slot+1 == shuttle_msg[SHUTTLE_SLOT]:  # new slot
            order_proof_shuttle = shuttle_msg[SHUTTLE_ORDER_PROOF]
            order_proof_is_valid = check_order_proof_validity(order_proof_shuttle)
            if order_proof_is_valid:
                pass
            else:
                self.mode = REPLICA_IMMUTABLE


    def generate_shuttle_message(result_proof, order_proof, slot, operation):
        shuttle_msg = {}
        shuttle_msg[SHUTTLE_RESULT_PROOF] = result_proof
        shuttle_msg[SHUTTLE_ORDER_PROOF] = order_proof
        shuttle_msg[SHUTTLE_SLOT] = slot
        shuttle_msg[SHUTTLE_OPERATION] = operation
        return shuttle_msg

    def test_dict_object():
        _put(('movie', 'star'))
        _append(('movie', ' wars'))
        _get('movie')
        _slice(('movie', '0:2'))
        print(self.running_state)


def main():
    config(clock='Lamport')
    random_generator = Random.new().read

    replica1 = new(Replica, num=1)
    replica2 = new(Replica, num=1)

    key1 = RSA.generate(1024, random_generator)
    key2 = RSA.generate(1024, random_generator)

    unique_id_1 = uuid.uuid4().hex
    unique_id_2 = uuid.uuid4().hex


    keychain1 = {unique_id_2: key2.publickey().exportKey()}
    keychain2 = {unique_id_1: key1.publickey().exportKey()}


    setup(replica1, (True, False, unique_id_1, None, replica2, key1, keychain1))
    setup(replica2, (False, True, unique_id_2, replica1, None, key2, keychain2))


    start(replica1)
    start(replica2)
