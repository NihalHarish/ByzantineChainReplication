import uuid
import json
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA
from Crypto import Random
import time
import logging
import os
from constants import RESULT_SHUTTLE_FAILURE_TRIGGER, \
    CLIENT_REQUEST_FAILURE_TRIGGER, \
    SHUTTLE_FAILURE_TRIGGER, FORWARDED_FAILURE_TRIGGER, \
    CHANGE_OPERATION_FAILURE, CHANGE_RESULT_FAILURE, \
    DROP_RESULT_FAILURE, REPLICA_PENDING, \
    REPLICA_ACTIVE, REPLICA_IMMUTABLE, SHUTTLE_RESULT_PROOF,\
    SHUTTLE_ORDER_PROOF, SHUTTLE_SLOT,\
    SHUTTLE_OPERATION, SHUTTLE_CHECKSUM,\
    SHUTTLE_CLIENT_ID, SHUTTLE, CHECKSUM,\
    CLIENT_ID, CLIENT_REQUEST_ID, RESULT,\
    STATUS, CHANGE_RESULT, CHANGE_OPERATION,\
    DROP_RESULT_STMT, CRASH, TRUNCATE_HISTORY,\
    SLEEP, DROP, INCREMENT_SLOT, EXTRA_OP,\
    INVALID_ORDER_SIG, INVALID_RESULT_SIG, DROP_CHECKPOINT_STMTS, \
    WEDGE_REQUEST_FAILURE_TRIGGER, NEW_CONFIGURATION_FAILURE_TRIGGER,\
    CHECKPOINT_FAILURE_TRIGGER, COMPLETE_CHECKPOINT_FAILURE_TRIGGER,\
    GET_RUNNING_STATE_FAILURE_TRIGGER, CATCH_UP_FAILURE_TRIGGER,\
    CLIENT_SIGNATURE



class Replica(process):

    def setup(isHead: bool, isTail: bool, unique_id: str,
              prev_replica: Replica, next_replica: Replica,
              key: instance, keychain: dict, clients_list: instance,
              head: Replica, clients: dict, timeout_val: int,
              client_keys: dict,
              olympus_public_key: instance,
              failures: instance,
              running_state: dict,
              head_replica_id: str, test_case: str, olympus: instance,
              t: int, checkpoint_limit: int,  config_number: int, last_client_operations: dict):

        self.unique_id = unique_id
        self.running_state = running_state
        self.history = []
        self.result_proof = []
        self.order_proof = []
        self.mode = REPLICA_ACTIVE
        self.prev_replica = prev_replica
        self.next_replica = next_replica
        self.public_keys = {}
        self.private_key = None
        self.result_shuttle_cache = {}
        self.checkpoint_proof_cache = {}
        self.isHead = isHead
        self.isTail = isTail
        self.current_slot = 0
        self.retransmission = {}
        self.waiting_for_result_shuttle = {}
        self.passport = key
        self.operations_dispatcher = {
            'put': self._put,
            'append': self._append,
            'slice': self._slice,
            'get': self._get
        }
        _build_key_chain(keychain)
        self.client_list = clients_list
        self.head_replica = head
        self.head_replica_id = head_replica_id
        self.logger = None
        self.olympus_public_key = olympus_public_key
        self.clients = clients  # dict: key: client uuid, value: client object
        self.client_keys = client_keys
        self.timeout_val = timeout_val / 1000
        self.failures = failures
        self.failure_trigger_dict = {
            CHANGE_RESULT: False,
            CHANGE_OPERATION: False,
            DROP_RESULT_STMT: False,
            CRASH: False,
            TRUNCATE_HISTORY: False,
            SLEEP: False,
            DROP: False,
            INCREMENT_SLOT: False,
            EXTRA_OP: False,
            INVALID_ORDER_SIG: False,
            INVALID_RESULT_SIG: False,
            DROP_CHECKPOINT_STMTS: False,

        }
        self.phase3_failure = {
                WEDGE_REQUEST_FAILURE_TRIGGER: 0,
                NEW_CONFIGURATION_FAILURE_TRIGGER: 0,
                CHECKPOINT_FAILURE_TRIGGER: 0,
                COMPLETE_CHECKPOINT_FAILURE_TRIGGER: 0,
                GET_RUNNING_STATE_FAILURE_TRIGGER:0,
                CATCH_UP_FAILURE_TRIGGER: 0
        }
        self.failure_forward_request_number = {}

        self.test_case = test_case
        self.checkpoint_count = 1
        self.olympus = olympus
        self.t = t
        self.checkpoint_limit = checkpoint_limit
        self.checkpoint_cache = None

        self.replica_life = False
        self.invalid_bytes = SHA256.new('invalid'.encode('utf-8')).digest()
        self.config_number = config_number
        self.last_client_operations = last_client_operations
        self.truncate_last_n_entries = 0

    def _build_key_chain(keychain):
        for replica_id, public_key in keychain.items():
            self.public_keys[replica_id] = RSA.importKey(public_key)

    '''
        Dictionary Operations

    '''

    def _put(params):
        key = params['key']
        value = params['value']
        self.running_state[key] = value
        return 'OK'

    def _append(params):
        key = params['key']
        new_value = params['value']
        if key in self.running_state:
            early_value = self.running_state[key]
            self.running_state[key] = early_value + new_value
            return 'OK'
        else:
            return 'fail'

    def _get(params):
        key = params['value']
        if key in self.running_state:
            return self.running_state[key]
        return 'fail'

    def _slice(params):
        key = params['key']
        value = params['value']
        if key in self.running_state:
            early_value = self.running_state[key]
            start, end = value.split(':')
            if start == '' and end != '':
                end = int(end)
                self.running_state[key] = early_value[: end]
            elif start != '' and end == '':
                start = int(start)
                self.running_state[key] = early_value[start:]
            else:
                start = int(start)
                end = int(end)
                if end > start:
                    self.running_state[key] = early_value[start:end]
                else:
                    return 'fail'
            return 'OK'
        else:
            return 'fail'

    def init_logger():
        '''
        This method is responsible for initlializing replica logger
        It creates log files at appropriate test folder
        head replica creates replia_head.log
        tail replica create replica_tail.log
        any other replica creates replica_unique_id.log

        '''
        logging_directory = os.path.join(os.path.dirname(
            os.path.abspath(__file__)),
            '../logs/{0}'.format(test_case))
        if isHead:
            logger = logging.getLogger(os.path.join(logging_directory,
                                                    'replica_head'))
        elif isTail:
            logger = logging.getLogger(os.path.join(logging_directory,
                                                    'replica_tail'))
        else:
            logger = logging.getLogger(
                os.path.join(
                    logging_directory,
                    'replica_{0}'.format(unique_id)))

        logger.setLevel(logging.INFO)
        if isHead:
            fh = logging.FileHandler(os.path.join(logging_directory,
                                                  'replica_head.log'))
        elif isTail:
            fh = logging.FileHandler(os.path.join(logging_directory,
                                                  'replica_tail.log'))
        else:
            fh = logging.FileHandler(
                os.path.join(
                    logging_directory,
                    'replica_{0}.log'.format(unique_id)))
        fh.setLevel(logging.INFO)
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s')
        fh.setFormatter(formatter)
        logger.addHandler(fh)

    def validate_olympus(message):
        signature, nonce = message
        if self.olympus_public_key.verify(nonce, signature):
            return True
        return False


    def run():
        '''
            Run forever
        '''
        init_logger()
        logger.info('{0}: Replica is running '.format(self))
        self.check_failure_phase_3(NEW_CONFIGURATION_FAILURE_TRIGGER)
        await(self.replica_life)
        logger.info('{0}: Replica has died '.format(self))

    def _change_result(result_shuttle_proof):
        '''
            This replica uses the hash of 'OK', instead of the hash of
            the actual result, in its result statement.
            It removes its own statement from the result proof,
            and adds a wrong result statement to the result_proof
        '''
        logger.error('{0}: Replica is running failure => \
                change_result()'.format(self))
        print('{0}: Replica is running failure => \
                change_result()'.format(self))
        bad_result_shuttle_proof = result_shuttle_proof.copy()
        updated_result_statement = None
        old_result_statement = None
        for proof in result_shuttle_proof:
            signature, statement, replica_id = proof
            if replica_id == unique_id:
                type_msg, result_hash, status = statement
                old_result_statement = proof
                updated_result_statement = (
                    signature, (type_msg, compute_hash_of_ok(), status), replica_id)
        bad_result_shuttle_proof.remove(old_result_statement)
        bad_result_shuttle_proof.append(updated_result_statement)
        print('Hash of OK =>', compute_hash_of_ok())
        return bad_result_shuttle_proof

    def _change_operation(operation):
        '''
            Replica uses get('x') as the operation in its
            order statement and result statement
        '''
        logger.error('{0}: Replica is running failure => \
                change_operation()'.format(self))
        print('{0}: Replica is running failure => \
                change_operation()'.format(self))

        bad_operation = operation.copy()
        bad_operation['opr'] = 'get'
        bad_operation['payload'] = operation['payload'].copy()
        bad_operation['payload']['key'] = None
        bad_operation['payload']['value'] = 'X'
        return bad_operation

    def _drop_result_stmt(result_shuttle_proof):
        '''
            Omit the head's result statement from the result proof.
        '''
        logger.error('{0}: Replica is running failure => \
                drop_result_stmt()'.format(self))
        print('{0}: Replica is running failure => \
                drop_result_stmt()'.format(self))
        dropped_result_shuttle_proof = result_shuttle_proof.copy()
        head_result_statement = None
        for proof in dropped_result_shuttle_proof:
            _, _, replica_id = proof
            if replica_id == head_replica_id:
                head_result_statement = proof
        dropped_result_shuttle_proof.remove(head_result_statement)
        return dropped_result_shuttle_proof

    def update_current_slot_number():
        '''
            Replica updates the slot number when it
            receives a client-req message
        '''
        logger.info(
            'Incrementing the current slot number to: {0}'.format(
                self.current_slot + 1))
        self.current_slot += 1

    def compute_running_state_hash():
        '''
            Computes the hash of the current running state dict
        '''
        running_state_json = json.dumps(self.running_state).encode('utf-8')
        return SHA256.new(running_state_json).hexdigest()

    def generate_result_statement(result_hash, status):
        '''
            It generates a result_statement in the form of
            (result, hash_of_running_state, status)
        '''
        statement = ('result', result_hash, status)  # adds status also
        return statement

    def sign_result_statement(result_statement):
        '''
            Signing the result statement with its private key
        '''
        result_stm = json.dumps(result_statement).encode('utf-8')
        result_statement_hash = SHA256.new(result_stm).digest()
        if self.failure_trigger_dict[INVALID_RESULT_SIG]:
            self.failure_trigger_dict[INVALID_RESULT_SIG] = False
            logger.info('invalid result proof signature performed')
            print(self, ' invalid result proof signature performed')
            signature = self.passport.sign(invalid_bytes, '')
        else:
            signature = self.passport.sign(result_statement_hash, '')

        return (signature, result_statement, self.unique_id)

    def add_to_result_proof(signed_result_proof):
        '''
            Appends the signed_result_proof to the result_proof
        '''
        self.result_proof = []
        self.result_proof.append(signed_result_proof)

    def generate_order_statement(slot, operation):
        '''
            Create order statement of the form
            (order, slot_number, operation_with_payload)
        '''
        order_statement = ('order', slot, operation)
        return order_statement

    def sign_order_statement(order_statement):
        '''
            Signing the order statement with private key
        '''
        order_stm = json.dumps(order_statement).encode('utf-8')
        order_statement_hash = SHA256.new(order_stm).digest()
        if self.failure_trigger_dict[INVALID_ORDER_SIG]:
            self.failure_trigger_dict[INVALID_ORDER_SIG] = False
            logger.info('invalid order proof signature performed')
            print('{0}: Replica is running'.format(self))
            print(self, ' invalid order proof signature performed')
            signature = self.passport.sign(invalid_bytes, '')
        else:
            signature = self.passport.sign(order_statement_hash, '')
        return (signature, order_statement, self.unique_id)

    def add_to_order_proof(signed_order_statement):
        '''
            Add the signed order statement to the order proof
        '''
        self.order_proof = []
        self.order_proof.append(signed_order_statement)

    def generate_history_statement(slot, operation, order_proof, client_signature):
        '''
            Creates history statement of the form
            (slot_number, operation, order_proof, client_signature)
        '''
        history_statement = (slot, operation, order_proof, client_signature)
        return history_statement

    def add_to_history(history_statement):
        '''
            Adds history_statement to its history object
        '''
        self.history.append(history_statement)

    def perform_operation(operation):
        '''
            Dictionary operation dispatcher
        '''
        opr = operation['opr']
        payload = operation['payload']
        if opr == 'put' or opr == 'append' or opr == 'slice' or opr == 'get':
            status = self.operations_dispatcher[opr](payload)
            return status
        return 'fail'

    def handle_operation(operation, client_info):
        '''
            Handler called by the head when client sends a new operation
            1. This updates our failure status method for
                trigger: client_request()
            2. It performs the operation by updating slot number,
                generating result and order proof,
                updating history and dispatching a shuttle message

        '''
        if self.failures is not None:
            check_failure('client_request', operation)
        if self.failure_trigger_dict[DROP]:
            logger.info('dropping client request')
            print(self, ' dropping client request')
            self.failure_trigger_dict[DROP] = False
            return

        if self.isHead:
            update_current_slot_number()
            status = perform_operation(operation)
            if failure_trigger_dict[CHANGE_OPERATION]:
                logger.info('Failure is triggered now: \
                        Change operation to get(x): {0}'.format(self.result_proof))
                print('Failure is triggered now: \
                        Change operation to get(x)')
                failure_trigger_dict[CHANGE_OPERATION] = False
                operation = _change_operation(operation)
            generate_result_proof(status)
            generate_order_proof(operation)
            client_id, client_request_id, client_signature = client_info
            update_history(self.current_slot, operation, self.order_proof, client_signature)
            client_load = (client_id, client_request_id)
            client_info_checksum = SHA256.new(
                json.dumps(client_load).encode('utf-8')).hexdigest()
            wait_for_result_shuttle(client_info_checksum)
            shuttle_msg = generate_shuttle_message(
                self.result_proof,
                self.order_proof,
                self.current_slot,
                operation,
                client_info_checksum,
                client_id,
                client_request_id,
                client_signature)
            dispatch_shuttle_message(shuttle_msg)

    def compute_hash_of_ok():
        '''
            computes hash of ok
        '''
        return SHA256.new('OK'.encode('utf-8')).hexdigest()

    def generate_result_proof(status, fail=False):
        '''
            Creates fresh new result_proof
            (with its own result_statement in there)
        '''
        if fail:
            result_hash = compute_hash_of_ok()
        else:
            result_hash = compute_running_state_hash()
        result_statement = generate_result_statement(result_hash, status)
        signed_result_statement = sign_result_statement(result_statement)
        add_to_result_proof(signed_result_statement)

    def generate_order_proof(operation):
        '''
            Main handler for adding signed order statement to its order proof
        '''
        slot = self.current_slot
        order_statement = generate_order_statement(slot, operation)
        signed_order_statement = sign_order_statement(order_statement)
        add_to_order_proof(signed_order_statement)

    def update_history(slot, operation, order_proof, client_signature):
        history_statement = generate_history_statement(slot,
                                                       operation, order_proof, client_signature)
        add_to_history(history_statement)

    def wait_for_result_shuttle(checksum):
        '''
            Replica change their result shuttle waiting status to True
        '''
        waiting_for_result_shuttle[checksum] = True

    def dispatch_shuttle_message(shuttle_message):
        '''
            Method for dispatching shuttle message to next replica
        '''
        print(self, 'sending shuttle message to ', next_replica)
        logger.info(
            '{0} sending shuttle message to {1}'.format(
                self, next_replica))
        logger.info("I think it will crash now")
        send((SHUTTLE, shuttle_message), to=next_replica)
        await(False)

    def check_order_proof_validity(order_proof_list):
        '''
            Method for checking if all slot numbers are
            the same and all hashes are consistent
            It returns False as soon as it notices some inconsistency
        '''
        slot = None
        operation = None
        for order_statement in order_proof_list:
            signature, statement, replica_id = order_statement
            _, statement_slot, statement_operation = statement
            statement_hash = SHA256.new(
                json.dumps(statement).encode('utf-8')).digest()
            public_key = self.public_keys[replica_id]
            if(public_key.verify(statement_hash, signature)):
                if slot is None:
                    _, slot, operation = statement
                else:
                    if slot != statement_slot or \
                            operation != statement_operation:
                        return False
            else:
                logger.error('Order proof verification failed')
                print('Order proof verification failed ',
                      replica_id)
                return False
        return True

    def populate_order_proof(order_proof_list):
        '''
            Adds all the order_proof statments from
            shuttle message into its order proof
        '''
        for order_statement in order_proof_list:
            self.order_proof.append(order_statement)

    def populate_result_proof(result_proof_list):
        '''
            Adds all the result_proof statments from
            shuttle message into its result proof
        '''
        for result_statement in result_proof_list:
            self.result_proof.append(result_statement)

    def check_result_proof_validity(result_proof_list):
        '''
            This checks the result proof validity in the
            normal shuttle message(dispatched from head)
        '''
        logger.info(
            'Checking result proof validity of {0}'.format(result_proof_list))
        hashed_running_state = compute_running_state_hash()
        for result_statement in result_proof_list:
            # (signature, ('result', result_hash, status), replica_id)
            signature, statement, replica_id = result_statement
            _, result_hash, _ = statement
            # for validating if the correct sender has sent the message
            hashed_statement = SHA256.new(
                json.dumps(statement). encode('utf-8')).digest()
            public_key = self.public_keys[replica_id]
            if public_key.verify(hashed_statement, signature):
                if hashed_running_state != result_hash:
                    print(result_proof_list)
                    logger.error('Result proof is INCONSISTENT')
                    print('>>>>>>>>Result proof is INCONSISTENT')
                    return False
            else:
                return False  # wrong sender
        return True

    def validate_client_signature(signed_message):
        '''
            Crisp method to verify clients authenticity
        '''
        signature, nonce, client_id = signed_message
        pub_client = self.client_keys[client_id]
        if pub_client.verify(nonce, signature):
            return True
        return False


    def receive(
            msg=(
                'client-request',
                client_payload,
                client_signature),
            from_=c):
        '''
            Client request operation handler.
        '''
        if validate_client_signature(client_signature) and self.mode != REPLICA_IMMUTABLE:
            operation = {}
            operation['client_id'] = client_payload['client_id']
            operation['request_id'] = client_payload['request_number']
            operation['opr'] = client_payload['opr']
            operation['payload'] = {}
            operation['payload']['key'] = client_payload['payload']['key']
            operation['payload']['value'] = client_payload['payload']['value']
            client_info = (operation['client_id'], operation['request_id'], client_signature)
            checkpoint_count += 1
            logger.info("Checkpoint limit has been set {0}".format(checkpoint_limit))
            if checkpoint_count % checkpoint_limit == 0:
                print('the checkpoint count is ', checkpoint_count, checkpoint_limit)
                checkpoint_statement = generate_checkpoint_statement()
                signed_checkpoint_msg = generate_signed_checkpoint_message(checkpoint_statement)
                print('{0} sending checkpoint to {1} {2}'.format(self, next_replica, [signed_checkpoint_msg]))
                send(('checkpoint', [signed_checkpoint_msg]), to=next_replica)
                checkpoint_count = 1
            handle_operation(operation, client_info)

    def generate_signed_checkpoint_message(checkpoint_statement):
        chkpnt_stm = json.dumps(checkpoint_statement).encode('utf-8')
        chkpnt_statement_hash = SHA256.new(chkpnt_stm).digest()
        signature = self.passport.sign(chkpnt_statement_hash , '')
        return (signature, checkpoint_statement, self.unique_id)

    def generate_checkpoint_statement():
        checkpoint_msg = (compute_running_state_hash(), self.current_slot)
        return checkpoint_msg

    def check_failure(type_failure, payload):
        '''
            This is responsible for updating the failure status.
            It iterates through the failure lists and checks if
            that client and request number matches to trigger the failure.
        '''
        logger.info("Check Failure has been called")
        for failure_tuple in self.failures:
            logger.info("Type Failure: {0}".format(type_failure))
            logger.info("Failure Tuple: {0}".format(failure_tuple))
            if type_failure in failure_tuple:
                print(failure_tuple)
                logger.info("Point A")
                _, from_which_client, \
                    message_number, action, failure_config_number, extra_args, action_args = failure_tuple
                print('Failure config number {0} and current config number {1}'.format(failure_config_number, self.config_number))
                logger.info("Failure action: {0}".format(action))
                logger.info("Failure action args: {0}".format(action_args))
                if failure_config_number != self.config_number:
                    continue
                # extract message number and client id from the payload
                # then check the index of the client id in the client list and
                # try matching it with the client mentioned in the failure
                client_id = payload[SHUTTLE_CLIENT_ID]
                try:
                    req_id = payload['request_id']
                except KeyError:
                    try:
                        req_id = payload[CLIENT_REQUEST_ID]
                    except KeyError:
                        req_id = payload['request_number']
                client_process = self.clients[client_id]
                print('Printing failure information {0} {1} {2}'.format(req_id, message_number, self.last_client_operations[client_id]))
                print(req_id == message_number + self.last_client_operations[client_id], self.client_list.index(client_process), from_which_client, client_list)
                if type_failure == 'forwarded_request':
                    if self.failure_forward_request_number[client_id] == \
                            message_number + self.last_client_operations[client_id] and \
                            self.client_list.index(client_process) == \
                            from_which_client:
                        logger.info('A failure has been scheduled to run next')
                        failure_trigger_dict[action] = True
                        if action == CRASH:
                            _crash()
                        elif action == SLEEP:
                            logger.info("Sleep action has been found")
                            _go_to_sleep(int(action_args))
                        elif action == INCREMENT_SLOT:
                            failure_trigger_dict[action] = False
                            if self.isHead:
                                print('Head is incrementing slot')
                                update_current_slot_number()
                        elif action == EXTRA_OP:
                            logger.info('failure: perform {a:a}')
                            print(self, ' failure: perform {a:a}')
                            failure_trigger_dict[action] = False
                            _put({'key':'a', 'value':'a'})
                        elif action == TRUNCATE_HISTORY:
                            logger.info('will truncate last n entries from history')
                            self.truncate_last_n_entries = int(action_args)
                elif req_id == message_number + self.last_client_operations[client_id] and \
                        self.client_list.index(client_process) == \
                        from_which_client:
                    logger.info(
                        'Scheduled failure during {0}'.format(type_failure))
                    print('Scheduled failure action during ',
                          type_failure, ' and the client index is ',
                          from_which_client, ' and for request number ',
                          req_id)
                    failure_trigger_dict[action] = True
                    if action == CRASH:
                        _crash()
                    elif action == SLEEP:
                        logger.info("Sleep action has been found")
                        _go_to_sleep(int(action_args))
                    elif action == INCREMENT_SLOT:
                        failure_trigger_dict[action] = False
                        if self.isHead:
                            print('Head is incrementing slot')
                            update_current_slot_number()
                    elif action == EXTRA_OP:
                        logger.info('failure: perform {a:a}')
                        print(self, ' failure: perform {a:a}')
                        failure_trigger_dict[action] = False
                        _put({'key':'a', 'value':'a'})
                    elif action == TRUNCATE_HISTORY:
                        logger.info('will truncate last n entries from history')
                        self.truncate_last_n_entries = int(action_args)


    def check_failure_phase_3(type_failure):
        logger.info("Check Failure Phase 3 has been called")
        for failure_tuple in self.failures:
            print(failure_tuple, type_failure)
            if type_failure in failure_tuple:
                _, _, message_number, action, failure_config_number, extra_args, action_args = failure_tuple
                logger.info("Failure action: {0}".format(action))
                logger.info("Failure action args: {0}".format(action_args))
                if failure_config_number != self.config_number:
                    continue
                self.phase3_failure[type_failure] += 1
                print(self.phase3_failure[type_failure], extra_args, type_failure)
                if (self.phase3_failure[type_failure] == extra_args and (type_failure in [CHECKPOINT_FAILURE_TRIGGER, COMPLETE_CHECKPOINT_FAILURE_TRIGGER])) or (type_failure not in [CHECKPOINT_FAILURE_TRIGGER, COMPLETE_CHECKPOINT_FAILURE_TRIGGER]):
                    logger.info('Setting {0} failure'.format(type_failure))
                    print('Setting {0} failure'.format(type_failure))
                    failure_trigger_dict[action] = True
                    if action == CRASH:
                        _crash()
                    elif action == SLEEP:
                        logger.info("Sleep action has been found")
                        _go_to_sleep(int(action_args))
                    elif action == INCREMENT_SLOT:
                        failure_trigger_dict[action] = False
                        if self.isHead:
                            print('Head is incrementing slot')
                            update_current_slot_number()
                    elif action == EXTRA_OP:
                        logger.info('failure: perform {a:a}')
                        print(self, ' failure: perform {a:a}')
                        failure_trigger_dict[action] = False
                        _put({'key':'a', 'value':'a'})
                    elif action == TRUNCATE_HISTORY:
                        logger.info('will truncate last n entries from history')
                        self.truncate_last_n_entries = int(action_args)

    def _go_to_sleep(sleep_time):
        failure_trigger_dict[SLEEP] = False
        logger.info('going to sleep')
        print('sleep time is of type ', type(sleep_time))
        sleep_time /= 1000
        print(self, 'going to sleep for ', sleep_time, ' seconds')
        time.sleep(sleep_time)
        print(self,' has woken up')

    def _crash():
        failure_trigger_dict[CRASH] = False
        print(self, ' is crashing')
        logger.info('crashing')
        # logging.shutdown()
        os._exit(-1)



    def receive(msg=('shuttle', payload), from_=prev_replica):
        '''
            Shuttle message handler.
            Replica on receiving this performs the operation after validating
            result and order proof.

            It also contains failure trigger points which tries to update the
            failure status.

            When the replica is tail, it sends the result to the client and
            dispatches the result shuttle back to its previous replica.

            Replica change their mode to IMMUTABLE if validation fails
        '''
        shuttle_msg = payload

        if self.current_slot + 1 == shuttle_msg[SHUTTLE_SLOT] and self.mode != REPLICA_IMMUTABLE:  # new slot
            logger.info('Point 0.2')
            if self.failures is not None:
                check_failure('shuttle', payload)
            if self.failure_trigger_dict[DROP]:
                self.failure_trigger_dict[DROP] = False
                logger.info('Dropping shuttle msg')
                print(self, ' is dropping shuttle msg')
                return
            order_proof_shuttle = shuttle_msg[SHUTTLE_ORDER_PROOF]
            order_proof_is_valid = check_order_proof_validity(order_proof_shuttle)
            if order_proof_is_valid:
                operation = shuttle_msg[SHUTTLE_OPERATION]
                update_current_slot_number()
                status = perform_operation(operation)
                if failure_trigger_dict[CHANGE_OPERATION]:
                    failure_trigger_dict[CHANGE_OPERATION] = False
                    logger.info(
                        'Before change_operation(), order proof was {0}'.format(order_proof_shuttle))
                    print('Before change_operation(), order proof was',
                          order_proof_shuttle)
                    operation = _change_operation(operation)
                    logger.info(
                        'change_operation() has changed operation to {0}'.format(operation))
                    print(
                        'CHANGING THE OPERATION TO GET(\'X\') IN SHUTTLE_MESSAGE',
                        operation)
                result_proof_shuttle = shuttle_msg[SHUTTLE_RESULT_PROOF]
                if check_result_proof_validity(result_proof_shuttle):
                    generate_order_proof(operation)
                    populate_order_proof(order_proof_shuttle)
                    generate_result_proof(status)
                    populate_result_proof(result_proof_shuttle)
                    client_signature = shuttle_msg[CLIENT_SIGNATURE]
                    update_history(self.current_slot, operation,
                                   self.order_proof, client_signature)
                    checksum = shuttle_msg[CHECKSUM]
                    client_id = shuttle_msg[CLIENT_ID]
                    client_request_id = shuttle_msg[CLIENT_REQUEST_ID]
                    wait_for_result_shuttle(checksum)
                    shuttle_msg = generate_shuttle_message(
                        self.result_proof,
                        self.order_proof,
                        shuttle_msg[SHUTTLE_SLOT],
                        operation,
                        checksum,
                        client_id,
                        client_request_id,
                        client_signature)
                    if self.isTail:
                        result_shuttle_msg = shuttle_msg
                        result_shuttle_msg[RESULT] = self.running_state
                        result_shuttle_msg[STATUS] = status
                        if failure_trigger_dict[CHANGE_RESULT]:
                            failure_trigger_dict[CHANGE_RESULT] = False
                            wrong_result_statement = _change_result(
                                result_shuttle_msg[SHUTTLE_RESULT_PROOF])
                            result_shuttle_msg[
                                SHUTTLE_RESULT_PROOF] = wrong_result_statement
                            self.result_proof = wrong_result_statement
                            logger.info('Changing the result to hash(ok) at \
                                    tail {0}'.format(self.result_proof))
                            print(
                                'CHANGING THE RESULT TO HASH(OK) AT TAIL',
                                self.result_proof)

                        if failure_trigger_dict[DROP_RESULT_STMT]:
                            failure_trigger_dict[DROP_RESULT_STMT] = False
                            dropped_result_proof = _drop_result_stmt(
                                result_shuttle_msg[SHUTTLE_RESULT_PROOF])
                            result_shuttle_msg[
                                SHUTTLE_RESULT_PROOF] = dropped_result_proof
                            self.result_proof = dropped_result_proof
                            logger.info(
                                'Dropping the head statement at tail {0}'.format(
                                    self.result_proof))
                            print(
                                'DROPPING THE HEAD AT TAIL',
                                self.result_proof)

                        # COMMENT THIS FOR FORWARDED REQUEST
                        self.result_shuttle_cache[
                            checksum] = result_shuttle_msg
                        # print('arrived at the tail and sending to ', self.clients[client_id], ' answer ', self.running_state)
                        send(('result',
                              (self.running_state,
                               self.result_proof,
                               status,
                               client_request_id)),
                             to=self.clients[client_id])
                        logger.info('Shuttle has arrived at tail.\
                                Running state: {0}'.format(str(self.running_state)))
                        send(('result_shuttle', result_shuttle_msg),
                             to=prev_replica)
                    else:
                        dispatch_shuttle_message(shuttle_msg)
                else:
                    logger.error('Replica becomes immutable as result \
                            proof validation failed')
                    print('Replica becomes immutable as result proof validation failed')
                    self.mode = REPLICA_IMMUTABLE
                    send(('reconfigure-request'), to=olympus)
            else:
                logger.error('Replica becomes immutable as order \
                        proof validation failed')
                print('Replica becomes immutable as order proof validation failed')
                self.mode = REPLICA_IMMUTABLE
                send(('reconfigure-request'), to=olympus)
        else:
            if self.mode != REPLICA_IMMUTABLE:
                self.mode = REPLICA_IMMUTABLE
                print(self, ' received bad slot during shuttle')
                send(('reconfigure-request'), to=olympus)

    def validate_complete_result_shuttle(complete_result_proof):
        '''
            This is a method to validate if all the result statements
            are consistent in the result shuttle message
        '''
        result_digest = None
        for result_statement in complete_result_proof:
            signature, statement, replica_id = result_statement
            _, result_hash, _ = statement  # ('result', result_hash, status)
            if result_digest is None:
                result_digest = result_hash
            # for validating if the correct sender has sent the message
            hashed_statement = SHA256.new(
                json.dumps(statement). encode('utf-8')).digest()
            public_key = self.public_keys[replica_id]
            if public_key.verify(hashed_statement, signature):
                if result_digest != result_hash:
                    return False
            else:
                return False  # The result_statement has been changed because of failure injection
        return True

    def receive(msg=('die-now', signed_message), from_=next_replica):
        if validate_olympus(signed_message) == False:
            print("Failed to validate olympus signature for die-now request")
            logger.error("Failed to validate olympus signature for die-now request")
            return
        self.replica_life = True
        logger.info('The value of self.replica_life has been changed to {0}'.format(self.replica_life))
        os._exit(1)

    def receive(msg=('result_shuttle', payload), from_=next_replica):
        '''
            This is a result_shuttle message handler.
            On receiving this message, the replica validates it and forwards
            it to its previous replica.
            It also checks if the client has made a
            retransmission request for
            that result, if yes, then it sends it to the client.
            It also saves the result_shuttle in its cache
        '''
        print(self, ': Receiving result shuttle from ', next_replica)
        logger.info(
            '{0}: Receiving result shuttle from {1}'.format(
                self, next_replica))
        complete_result_proof = payload[SHUTTLE_RESULT_PROOF]

        if self.failures is not None:
            check_failure('result_shuttle', payload)
        if self.failure_trigger_dict[DROP]:
            self.failure_trigger_dict[DROP] = False
            print(self, ' drops result shuttle message')
            logger.info('dropping result shuttle message')
            return

        if validate_complete_result_shuttle(complete_result_proof):
            result_shuttle = payload
            checksum = result_shuttle[CHECKSUM]
            # used during retransmission scenario
            self.result_shuttle_cache[checksum] = result_shuttle
            del self.waiting_for_result_shuttle[checksum]
            if failure_trigger_dict[CHANGE_RESULT]:
                failure_trigger_dict[CHANGE_RESULT] = False
                wrong_result_statement = _change_result(
                    result_shuttle[SHUTTLE_RESULT_PROOF])
                result_shuttle[SHUTTLE_RESULT_PROOF] = wrong_result_statement
                logger.info(
                    'New wrong result stm is {0}'.format(
                        result_shuttle[SHUTTLE_RESULT_PROOF]))
                print(
                    'This is the new wrong result_stm AT RESULT_SHUTTLE',
                    result_shuttle[SHUTTLE_RESULT_PROOF])

            if failure_trigger_dict[DROP_RESULT_STMT]:
                failure_trigger_dict[DROP_RESULT_STMT] = False
                dropped_result_proof = _drop_result_stmt(
                    result_shuttle[SHUTTLE_RESULT_PROOF])
                result_shuttle[SHUTTLE_RESULT_PROOF] = dropped_result_proof
                logger.info(
                    'Dropping the head result statement {0} and head replica id is {1}'.format(
                        dropped_result_proof, head_replica_id))
                print(
                    'DROPPING THE HEAD_RESULT_STMT AT RESULT_SHUTTLE',
                    dropped_result_proof,
                    head_replica_id)

            if checksum in self.retransmission:
                logger.info('Sending the result shuttle to client ')
                print('Sending the result shuttle to client ')
                client_id = self.retransmission[checksum]
                reply_to_client = self.clients[client_id]
                proof = result_shuttle[SHUTTLE_RESULT_PROOF]
                res = result_shuttle[RESULT]
                status = result_shuttle[STATUS]
                client_request_id = result_shuttle[CLIENT_REQUEST_ID]
                send(('result', (res, proof, status, client_request_id)),
                     to=reply_to_client)
                del self.retransmission[checksum]
            if not isHead:
                send(('result_shuttle', result_shuttle), to=prev_replica)
            elif isHead:
                logger.info('Received the complete result_shuttle ')
                print('Received the complete result_shuttle ',
                      len(result_shuttle[SHUTTLE_RESULT_PROOF]))

        else:
            logger.info('Result proof validation is wrong')
            print('RESULT PROOF IS WRONG, GOING TO IMMUTABLE STAGE')
            self.mode = REPLICA_IMMUTABLE
            print(self, 'here4')
            send(('reconfigure-request'), to=olympus)


    def validate_checkpoint(checkpoint_list, complete = False):
        reference_hashed_state = None
        reference_slot_number = None
        count_correct_hashes = 0
        for checkpoint_statement in checkpoint_list:
            signature, statement, replica_id = checkpoint_statement
            hashed_state, checkpoint_slot_number = statement  # (hashed_state, slot number)
            if reference_hashed_state is None:
                reference_hashed_state = hashed_state
            if reference_slot_number is None:
                reference_slot_number = checkpoint_slot_number
            # for validating if the correct sender has sent the message
            hashed_statement = SHA256.new(
                json.dumps(statement). encode('utf-8')).digest()
            public_key = self.public_keys[replica_id]
            if public_key.verify(hashed_statement, signature):
                if reference_hashed_state != hashed_state:
                    return False
                count_correct_hashes += 1
            else:
                return False
        if count_correct_hashes < self.t + 1 and complete == True:
            return False
        return True

    def truncate_history(signed_checkpoint_list):
        # pick any random entry from the list and remove the 
        checkpoint_msg = signed_checkpoint_list[0]
        _, checkpoint_statement, _ = checkpoint_msg
        _, max_slot_to_remove = checkpoint_statement
        print('truncating history', max_slot_to_remove)
        index = -1
        for pos, i in enumerate(self.history):
            if i[0] ==  max_slot_to_remove:
                 index = pos
        if index != -1:
            checkpoint_cache = signed_checkpoint_list
            # print('old history', self.history)
            self.history = self.history[index:]
            # print('new history', self.history)
            print('new history starts from: ', index)

    def receive(msg=('checkpoint', signed_checkpoint_payload), from_=prev_replica):
        if self.failures is not None:
            check_failure_phase_3(CHECKPOINT_FAILURE_TRIGGER)
        if self.failure_trigger_dict[DROP]:
            self.failure_trigger_dict[DROP] = False
            print(self, ' is dropping checkpoint message')
            logger.info('dropping checkpoint message')
            return
        if validate_checkpoint(signed_checkpoint_payload, complete=False):
            print(self, 'receiving checkpoint from ',prev_replica)
            checkpoint_statement = generate_checkpoint_statement()
            signed_checkpoint_msg = generate_signed_checkpoint_message(checkpoint_statement)
            signed_checkpoint_payload.append(signed_checkpoint_msg)
            if not isTail:
                send(('checkpoint', signed_checkpoint_payload), to=next_replica)
            else:
                truncate_history(signed_checkpoint_payload)
                send(('checkpoint_proof', signed_checkpoint_payload), to=prev_replica)
        else:
            print(self, 'Couldnot verify checkpoint message')
            send(('reconfigure-request'), to=olympus)

    def receive(msg=('checkpoint_proof', signed_checkpoint_list), from_=next_replica):
        if self.failures is not None:
            check_failure_phase_3(COMPLETE_CHECKPOINT_FAILURE_TRIGGER)
        if self.failure_trigger_dict[DROP]:
            print(self, ' is dropping checkpoint proof message')
            logger.info('dropping checkpoint proof message')
            self.failure_trigger_dict[DROP] = False
            return
        if validate_checkpoint(signed_checkpoint_list, complete=True):
            print(self, 'receiving complete checkpoint from ',next_replica)
            truncate_history(signed_checkpoint_list)
            if not isHead:
                if self.failure_trigger_dict[DROP_CHECKPOINT_STMTS]:
                    self.failure_trigger_dict[DROP_CHECKPOINT_STMTS] = False
                    print(self, ' is chopping off the first t+1 replicas checkpoints ', signed_checkpoint_list[self.t+1:])
                    # logger.info('chopping off first t+1 replicas from checkpoint {0}'.format(signed_checkpoint_list[self.t+1:]))
                    send(('checkpoint_proof', signed_checkpoint_list[self.t+1:]), to=prev_replica)
                else:
                    send(('checkpoint_proof', signed_checkpoint_list), to=prev_replica)
        else:
            print(self, 'checkpoint proof validation failed, making reconfigure request')
            # logger.info('checkpoint proof validation failed, making reconfigure request')
            send(('reconfigure-request'), to=olympus)

    def receive(msg=('retransmission', retrans_payload, client_signature),
                from_=c):
        '''
            This is a retransmission handler.
            This method is triggered when client sends a retransmission
            message, or replica forwards the retransmission
            message to the head

            Replica sends error to client if it is in IMMUTABLE stage
            Replica sends result if the result shuttle is present in the
            cache Or else, it forwards the message to head and runs a timeout

            Head replica runs in the same function. It checks if the operation
            is new and also runs a timeout.
        '''
        print('Received retransmission request')
        logger.info('Received retransmission req')
        if not validate_client_signature(client_signature):
            return
        client_info = (retrans_payload['client_id'],
                       retrans_payload['request_number'], client_signature)
        client_load = (retrans_payload['client_id'],
                       retrans_payload['request_number'])
        client_id = retrans_payload['client_id']
        checksum = SHA256.new(json.dumps(client_load).
                              encode('utf-8')).hexdigest()

        if client_id not in self.failure_forward_request_number:
            self.failure_forward_request_number[client_id] = -1
        else:
            self.failure_forward_request_number[client_id] += 1

        check_failure('forwarded_request', retrans_payload)
        check_failure('client_request', retrans_payload)
        if checksum not in self.retransmission:
            self.retransmission[checksum] = client_info[0]

        if self.mode == REPLICA_IMMUTABLE:
            reply_to_client = self.clients[client_id]
            logger.info('sending error to client as it is immutable')
            # print('SENDINGGGGGGGG ERROR TO CLIENT AS IT IS IMMUTABLE')
            # send(('error', 'immutable'), to=reply_to_client)

        elif checksum in self.result_shuttle_cache:  # checksum uniquely combines client id and request number
            print(self, 'sending result to client from its\
                    result_proof_cache', checksum)
            logger.info(self, 'sending result to client from \
                    its result_proof cache')
            proof = self.result_shuttle_cache[checksum][SHUTTLE_RESULT_PROOF]
            res = self.result_shuttle_cache[checksum][RESULT]
            status = self.result_shuttle_cache[checksum][STATUS]
            client_request_id = self.result_shuttle_cache[
                checksum][CLIENT_REQUEST_ID]
            reply_to_client = self.clients[client_id]

            # For the next outgoing message
            if self.failure_trigger_dict[CHANGE_RESULT]:
                self.failure_trigger_dict[CHANGE_RESULT] = False
                proof = _change_result(proof)
            if self.failure_trigger_dict[DROP_RESULT_STMT]:
                self.failure_trigger_dict[DROP_RESULT_STMT] = False
                proof = _drop_result_stmt(proof)
            print('send this data to client ', (res, status))
            logger.info(
                'sending this result to client {0}'.format(
                    (res, status)))
            send(('retrans-result', (res, proof, status, client_request_id)),
                 to=reply_to_client)
            # after sending the result, remove the entry from retransmission
            del self.retransmission[checksum]
        else:
            if not isHead:
                print('forwarding request to the head')
                logger.info('forwarding request to the head')
                send(('retransmission', retrans_payload), to=head_replica)
                if await(some(received(('result_shuttle', big_one)), has=(big_one[CHECKSUM] not in self.result_shuttle_cache) )):
                    print('Retransmission request being processed @nonhead')
                    print('this is the payload ', big_one)
                    logger.info('Retransmission request being processed @nonhead')
                elif timeout(self.timeout_val):
                    print ('Timeout occured at @nonhead')
                    logger.error('Timeout occured at @nonhead')
                    print('Timeout @nonhead: Have to send \
                            reconfigure message to Olympus')
                    logger.error('Timeout @nonhead: Have to send \
                            reconfigure message to Olympus')
                    print(self, 'here4')
                    if self.mode != REPLICA_IMMUTABLE:
                        self.mode = REPLICA_IMMUTABLE
                        send(('reconfigure-request'), to=olympus)
            else:
                if not self.waiting_for_result_shuttle[checksum]:
                    # We have create a new slot and perform fresh new operation
                    handle_operation(retrans_payload, client_info)
                if await(some(received(('result_shuttle', big_one)), has=(big_one[CHECKSUM] not in self.result_shuttle_cache))):
                    print('Retransmission request being processed @head')
                    logger.info('Retransmission request being processed @head')
                elif timeout(self.timeout_val):
                    # logger.info('Timeout expired at Head: \
                    #         Have to send reconfigure message to Olympus')
                    print('Timeout expird at Head: \
                            Have to send reconfigure message to Olympus')
                    print(self, 'here5')
                    if self.mode != REPLICA_IMMUTABLE:
                        self.mode = REPLICA_IMMUTABLE
                        send(('reconfigure-request'), to=olympus)

    def generate_caughtup_signature(caughtup_statement):
        caughtup_stm = json.dumps(caughtup_statement).encode('utf-8')
        caught_up_statement_hash = SHA256.new(caughtup_stm).digest()
        signature = self.passport.sign(caught_up_statement_hash , '')
        return (signature, caughtup_statement, self.unique_id)

    def receive(msg=('catchup-request', sequence_of_operations, signed_message), from_=olympus):
        # perform the sequence of operations in the current running state
        # send the hash of the current running state to the olympus
        # send caught up response
        if validate_olympus(signed_message) == False:
            logger.info('Olympus validation has failed for catchup request')
            return
        if self.failures is not None:
            check_failure_phase_3(CATCH_UP_FAILURE_TRIGGER)
        if self.failure_trigger_dict[DROP]:
            print(self, 'dropping catcup request')
            logger.info('dropping catchup request')
            self.failure_trigger_dict[DROP] = False
            return
        # print(self, 'received catchup-request for ', sequence_of_operations)
        for operations in sequence_of_operations:
            slot, opr = operations
            if slot == self.current_slot + 1:
                self.current_slot = slot
                status = perform_operation(opr)
                print(self, 'perfoming {0} {1} => {2}'.format(slot, opr, status))
            else:
                print(self, 'is not able to catchup coz its slot is', self.current_slot,' and slot received is ', slot)
        caughtup_statement = compute_running_state_hash()
        print(self, ' has finished catching up and new state is ',self.running_state, ' and hash is ', caughtup_statement)
        signed_caughtup_statement = generate_caughtup_signature(caughtup_statement)
        send(('caughtup-response', signed_caughtup_statement, self.config_number), to=olympus)

    def receive(msg=('get-running-state'), from_=olympus):
        if self.failures is not None:
            check_failure_phase_3(GET_RUNNING_STATE_FAILURE_TRIGGER)
        if self.failure_trigger_dict[DROP]:
            print(self, ' dropping get-running-state request')
            logger.info('dropping get-running-state request')
            self.failure_trigger_dict[DROP] = False
            return
        print(self, ' has finished catching up and new state is ',self.running_state, ' and hash is ', compute_running_state_hash())
        send(('running-state', self.running_state, compute_running_state_hash(), self.config_number), to=olympus)

    def generate_signed_wedge_statement(wedge_statement):
        wedge_stm = json.dumps(wedge_statement).encode('utf-8')
        wedge_statement_hash = SHA256.new(wedge_stm).digest()
        signature = self.passport.sign(wedge_statement_hash , '')
        return (signature, wedge_statement, self.unique_id)

    def generate_wedge_statement():
        if self.failure_trigger_dict[TRUNCATE_HISTORY]:
            self.failure_trigger_dict[TRUNCATE_HISTORY] = False
            print(self, 'sending truncated history as wedge response')
            logger.info('sending truncated history as wedge response')
            logger.info('earlier history {0}'.format(self.history))
            logger.info('truncated history {0}'.format(self.history[:-self.truncate_last_n_entries]))

            print('earlier history', self.history)
            print('truncated history', self.history[:-self.truncate_last_n_entries])

            wedge_statement = (self.checkpoint_cache, self.history[:-self.truncate_last_n_entries])
        else:
            wedge_statement = (self.checkpoint_cache, self.history)
        return wedge_statement

    def receive(msg=('wedge-request', signed_message), from_=olympus):
        # validate if it came from the olympus: TODO
        if validate_olympus(signed_message) == False:
            logger.info("Olympus Validation Failed")
            return
        if self.failures is not None:
            check_failure_phase_3(WEDGE_REQUEST_FAILURE_TRIGGER)
        if self.failure_trigger_dict[DROP]:
            logger.info('dropping the wedge-request')
            print(self, ' dropping the wedge-request')
            self.failure_trigger_dict[DROP] = False
            return
        print(self, ' receiving wedge')
        self.mode = REPLICA_IMMUTABLE
        wedge_statement = generate_wedge_statement()
        #signed_wedge_message = generate_signed_wedge_statement(wedge_statement)
        signed_wedge_message = generate_signed_wedge_statement(wedge_statement)
        # if not self.isTail:
        send(('wedge-response', signed_wedge_message, self.config_number), to=olympus)

    def generate_client_result_message(result_shuttle):
        '''
            This crafts a result for the client
        '''
        complete_result_proof = result_shuttle[SHUTTLE_RESULT_PROOF]
        final_result = result_shuttle[RESULT]
        return json.dumps((final_result, complete_result_proof))\
            .encode('utf-8')

    def generate_shuttle_message(result_proof, order_proof, slot,
                                 operation, checksum, client_id, request_id, client_signature):
        '''
            This is a method to generate shuttle message
        '''
        shuttle_msg = {}
        shuttle_msg[SHUTTLE_RESULT_PROOF] = result_proof
        shuttle_msg[SHUTTLE_ORDER_PROOF] = order_proof
        shuttle_msg[SHUTTLE_SLOT] = slot
        shuttle_msg[SHUTTLE_OPERATION] = operation
        shuttle_msg[CHECKSUM] = checksum
        shuttle_msg[CLIENT_ID] = client_id
        shuttle_msg[CLIENT_REQUEST_ID] = request_id
        shuttle_msg[CLIENT_SIGNATURE] = client_signature
        return shuttle_msg


def main():
    config(clock='Lamport')
    random_generator = Random.new().read

    replica1 = new(Replica, num=1)
    replica2 = new(Replica, num=1)
    replica3 = new(Replica, num=1)
    replica4 = new(Replica, num=1)

    key1 = RSA.generate(1024, random_generator)
    key2 = RSA.generate(1024, random_generator)
    key3 = RSA.generate(1024, random_generator)
    key4 = RSA.generate(1024, random_generator)

    unique_id_1 = uuid.uuid4().hex
    unique_id_2 = uuid.uuid4().hex
    unique_id_3 = uuid.uuid4().hex
    unique_id_4 = uuid.uuid4().hex

    keychain1 = {
        unique_id_2: key2.publickey().exportKey(),
        unique_id_3: key3.publickey().exportKey(),
        unique_id_4: key4.publickey().exportKey(),
        unique_id_1: key1.publickey().exportKey()
    }
    keychain2 = {
        unique_id_1: key1.publickey().exportKey(),
        unique_id_3: key3.publickey().exportKey(),
        unique_id_4: key4.publickey().exportKey(),
        unique_id_2: key2.publickey().exportKey()
    }
    keychain3 = {
        unique_id_1: key1.publickey().exportKey(),
        unique_id_2: key2.publickey().exportKey(),
        unique_id_4: key4.publickey().exportKey(),
        unique_id_3: key3.publickey().exportKey()
    }
    keychain4 = {
        unique_id_1: key1.publickey().exportKey(),
        unique_id_2: key2.publickey().exportKey(),
        unique_id_3: key3.publickey().exportKey(),
        unique_id_4: key4.publickey().exportKey()
    }

    client_dict = {}

    setup(
        replica1,
        (True,
         False,
         unique_id_1,
         None,
         replica2,
         key1,
         keychain1,
         None,
         replica1,
         client_dict,
         10,
         None,
         unique_id_1))
    setup(
        replica2,
        (False,
         False,
         unique_id_2,
         replica1,
         replica3,
         key2,
         keychain2,
         None,
         replica1,
         client_dict,
         10,
         None,
         unique_id_1))
    setup(
        replica3,
        (False,
         False,
         unique_id_3,
         replica2,
         replica4,
         key3,
         keychain3,
         None,
         replica1,
         client_dict,
         10,
         None,
         unique_id_1))
    setup(
        replica4,
        (False,
         True,
         unique_id_4,
         replica3,
         None,
         key4,
         keychain4,
         None,
         replica1,
         client_dict,
         10,
         None,
         unique_id_1))

    start(replica1)
    start(replica2)
    start(replica3)
    start(replica4)
