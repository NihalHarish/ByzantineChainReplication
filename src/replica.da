import uuid
import json
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA
from Crypto import Random
import time
import logging
import os
from constants import RESULT_SHUTTLE_FAILURE_TRIGGER, \
    CLIENT_REQUEST_FAILURE_TRIGGER, \
    SHUTTLE_FAILURE_TRIGGER, FORWARDED_FAILURE_TRIGGER, \
    CHANGE_OPERATION_FAILURE, CHANGE_RESULT_FAILURE, \
    DROP_RESULT_FAILURE, REPLICA_PENDING, \
    REPLICA_ACTIVE, REPLICA_IMMUTABLE, SHUTTLE_RESULT_PROOF,\
    SHUTTLE_ORDER_PROOF, SHUTTLE_SLOT,\
    SHUTTLE_OPERATION, SHUTTLE_CHECKSUM,\
    SHUTTLE_CLIENT_ID, SHUTTLE, CHECKSUM,\
    CLIENT_ID, CLIENT_REQUEST_ID, RESULT,\
    STATUS, CHANGE_RESULT, CHANGE_OPERATION,\
    DROP_RESULT_STMT


class Replica(process):

    def setup(isHead: bool, isTail: bool, unique_id: str,
              prev_replica: Replica, next_replica: Replica,
              key: instance, keychain: dict, clients_list: instance,
              head: Replica, clients: dict, timeout_val: int,
              client_keys: dict, failures: instance,
              running_state: dict,
              head_replica_id: str, test_case: str, olympus: instance):
        self.unique_id = unique_id
        self.running_state = running_state
        self.history = []
        self.result_proof = []
        self.order_proof = []

        self.mode = REPLICA_ACTIVE
        self.prev_replica = prev_replica
        self.next_replica = next_replica
        self.public_keys = {}
        self.private_key = None
        self.result_shuttle_cache = {}
        self.checkpoint_proof_cache = {}
        self.isHead = isHead
        self.isTail = isTail
        self.current_slot = 0
        self.config_number = 1
        self.retransmission = {}
        self.waiting_for_result_shuttle = {}
        self.passport = key
        self.operations_dispatcher = {
            'put': self._put,
            'append': self._append,
            'slice': self._slice,
            'get': self._get
        }
        _build_key_chain(keychain)
        self.client_list = clients_list
        self.head_replica = head
        self.head_replica_id = head_replica_id
        self.logger = None
        self.clients = clients  # dict: key: client uuid, value: client object
        self.client_keys = client_keys
        self.timeout_val = timeout_val
        # [(failure_trigger_msg, from_which_client, message_number, failure_action)]
        self.failures = failures
        self.failure_trigger_dict = {
            CHANGE_RESULT: False,
            CHANGE_OPERATION: False,
            DROP_RESULT_STMT: False
        }
        self.failure_forward_request_number = {}
        self.test_case = test_case
        self.checkpoint_limit = 3
        self.checkpoint_count = 1
        self.olympus = olympus
        self.checkpoint_cache = None

        self.replica_life = False

    def _build_key_chain(keychain):
        for replica_id, public_key in keychain.items():
            self.public_keys[replica_id] = RSA.importKey(public_key)

    '''
        Dictionary Operations

    '''

    def _put(params):
        key = params['key']
        value = params['value']
        self.running_state[key] = value
        return 'OK'

    def _append(params):
        key = params['key']
        new_value = params['value']
        if key in self.running_state:
            early_value = self.running_state[key]
            self.running_state[key] = early_value + new_value
            return 'OK'
        else:
            return 'fail'

    def _get(params):
        key = params['value']
        if key in self.running_state:
            return self.running_state[key]
        return 'fail'

    def _slice(params):
        key = params['key']
        value = params['value']
        if key in self.running_state:
            early_value = self.running_state[key]
            start, end = value.split(':')
            if start == '' and end != '':
                end = int(end)
                self.running_state[key] = early_value[: end]
            elif start != '' and end == '':
                start = int(start)
                self.running_state[key] = early_value[start:]
            else:
                start = int(start)
                end = int(end)
                if end > start:
                    self.running_state[key] = early_value[start:end]
                else:
                    return 'fail'
            return 'OK'
        else:
            return 'fail'

    def init_logger():
        '''
        This method is responsible for initlializing replica logger
        It creates log files at appropriate test folder
        head replica creates replia_head.log
        tail replica create replica_tail.log
        any other replica creates replica_unique_id.log

        '''
        logging_directory = os.path.join(os.path.dirname(
            os.path.abspath(__file__)),
            '../logs/{0}'.format(test_case))
        if isHead:
            logger = logging.getLogger(os.path.join(logging_directory,
                                                    'replica_head'))
        elif isTail:
            logger = logging.getLogger(os.path.join(logging_directory,
                                                    'replica_tail'))
        else:
            logger = logging.getLogger(
                os.path.join(
                    logging_directory,
                    'replica_{0}'.format(unique_id)))

        logger.setLevel(logging.INFO)
        if isHead:
            fh = logging.FileHandler(os.path.join(logging_directory,
                                                  'replica_head.log'))
        elif isTail:
            fh = logging.FileHandler(os.path.join(logging_directory,
                                                  'replica_tail.log'))
        else:
            fh = logging.FileHandler(
                os.path.join(
                    logging_directory,
                    'replica_{0}.log'.format(unique_id)))
        fh.setLevel(logging.INFO)
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s')
        fh.setFormatter(formatter)
        logger.addHandler(fh)

    def run():
        '''
            Run forever
        '''
        init_logger()
        logger.info('{0}: Replica is running '.format(self))
        print('{0}: Replica is running'.format(self))
        await(self.replica_life)
        logger.info('{0}: Replica has died '.format(self))

    def _change_result(result_shuttle_proof):
        '''
            This replica uses the hash of 'OK', instead of the hash of
            the actual result, in its result statement.
            It removes its own statement from the result proof,
            and adds a wrong result statement to the result_proof
        '''
        logger.error('{0}: Replica is running failure => \
                change_result()'.format(self))
        print('{0}: Replica is running failure => \
                change_result()'.format(self))
        bad_result_shuttle_proof = result_shuttle_proof.copy()
        updated_result_statement = None
        old_result_statement = None
        for proof in result_shuttle_proof:
            signature, statement, replica_id = proof
            if replica_id == unique_id:
                type_msg, result_hash, status = statement
                old_result_statement = proof
                updated_result_statement = (
                    signature, (type_msg, compute_hash_of_ok(), status), replica_id)
        bad_result_shuttle_proof.remove(old_result_statement)
        bad_result_shuttle_proof.append(updated_result_statement)
        print('Hash of OK =>', compute_hash_of_ok())
        return bad_result_shuttle_proof

    def _change_operation(operation):
        '''
            Replica uses get('x') as the operation in its
            order statement and result statement
        '''
        logger.error('{0}: Replica is running failure => \
                change_operation()'.format(self))
        print('{0}: Replica is running failure => \
                change_operation()'.format(self))

        bad_operation = operation.copy()
        bad_operation['opr'] = 'get'
        bad_operation['payload'] = operation['payload'].copy()
        bad_operation['payload']['key'] = None
        bad_operation['payload']['value'] = 'X'
        return bad_operation

    def _drop_result_stmt(result_shuttle_proof):
        '''
            Omit the head's result statement from the result proof.
        '''
        logger.error('{0}: Replica is running failure => \
                drop_result_stmt()'.format(self))
        print('{0}: Replica is running failure => \
                drop_result_stmt()'.format(self))
        dropped_result_shuttle_proof = result_shuttle_proof.copy()
        head_result_statement = None
        for proof in dropped_result_shuttle_proof:
            _, _, replica_id = proof
            if replica_id == head_replica_id:
                head_result_statement = proof
        dropped_result_shuttle_proof.remove(head_result_statement)
        return dropped_result_shuttle_proof

    def update_current_slot_number():
        '''
            Replica updates the slot number when it
            receives a client-req message
        '''
        logger.info(
            'Incrementing the current slot number to: {0}'.format(
                self.current_slot + 1))
        self.current_slot += 1

    def compute_running_state_hash():
        '''
            Computes the hash of the current running state dict
        '''
        running_state_json = json.dumps(self.running_state).encode('utf-8')
        return SHA256.new(running_state_json).hexdigest()

    def generate_result_statement(result_hash, status):
        '''
            It generates a result_statement in the form of
            (result, hash_of_running_state, status)
        '''
        statement = ('result', result_hash, status)  # adds status also
        return statement

    def sign_result_statement(result_statement):
        '''
            Signing the result statement with its private key
        '''
        result_stm = json.dumps(result_statement).encode('utf-8')
        result_statement_hash = SHA256.new(result_stm).digest()
        signature = self.passport.sign(result_statement_hash, '')
        return (signature, result_statement, self.unique_id)

    def add_to_result_proof(signed_result_proof):
        '''
            Appends the signed_result_proof to the result_proof
        '''
        self.result_proof = []
        self.result_proof.append(signed_result_proof)

    def generate_order_statement(slot, operation):
        '''
            Create order statement of the form
            (order, slot_number, operation_with_payload)
        '''
        order_statement = ('order', slot, operation)
        return order_statement

    def sign_order_statement(order_statement):
        '''
            Signing the order statement with private key
        '''
        order_stm = json.dumps(order_statement).encode('utf-8')
        order_statement_hash = SHA256.new(order_stm).digest()
        signature = self.passport.sign(order_statement_hash, '')
        return (signature, order_statement, self.unique_id)

    def add_to_order_proof(signed_order_statement):
        '''
            Add the signed order statement to the order proof
        '''
        self.order_proof = []
        self.order_proof.append(signed_order_statement)

    def generate_history_statement(slot, operation, order_proof):
        '''
            Creates history statement of the form
            (slot_number, operation, order_proof)
        '''
        # history_statement = json.dumps((slot, operation, order_proof))
        history_statement = (slot, operation, order_proof)
        return history_statement

    def add_to_history(history_statement):
        '''
            Adds history_statement to its history object
        '''
        self.history.append(history_statement)

    def perform_operation(operation):
        '''
            Dictionary operation dispatcher
        '''
        opr = operation['opr']
        payload = operation['payload']
        if opr == 'put' or opr == 'append' or opr == 'slice' or opr == 'get':
            status = self.operations_dispatcher[opr](payload)
            return status
        return 'fail'

    def handle_operation(operation, client_info):
        '''
            Handler called by the head when client sends a new operation
            1. This updates our failure status method for
                trigger: client_request()
            2. It performs the operation by updating slot number,
                generating result and order proof,
                updating history and dispatching a shuttle message

        '''
        if self.failures is not None:
            check_failure('client_request', operation)

        if self.isHead:
            update_current_slot_number()
            status = perform_operation(operation)
            if failure_trigger_dict[CHANGE_OPERATION]:
                logger.info('Failure is triggered now: \
                        Change operation to get(x): {0}'.format(self.result_proof))
                print('Failure is triggered now: \
                        Change operation to get(x)')
                failure_trigger_dict[CHANGE_OPERATION] = False
                operation = _change_operation(operation)
            generate_result_proof(status)
            generate_order_proof(operation)
            update_history(self.current_slot, operation, self.order_proof)
            client_id, client_request_id = client_info
            client_info_checksum = SHA256.new(
                json.dumps(client_info).encode('utf-8')).hexdigest()
            wait_for_result_shuttle(client_info_checksum)
            shuttle_msg = generate_shuttle_message(
                self.result_proof,
                self.order_proof,
                self.current_slot,
                operation,
                client_info_checksum,
                client_id,
                client_request_id)
            dispatch_shuttle_message(shuttle_msg)

    def compute_hash_of_ok():
        '''
            computes hash of ok
        '''
        return SHA256.new('OK'.encode('utf-8')).hexdigest()

    def generate_result_proof(status, fail=False):
        '''
            Creates fresh new result_proof
            (with its own result_statement in there)
        '''
        if fail:
            result_hash = compute_hash_of_ok()
        else:
            result_hash = compute_running_state_hash()
        result_statement = generate_result_statement(result_hash, status)
        signed_result_statement = sign_result_statement(result_statement)
        add_to_result_proof(signed_result_statement)

    def generate_order_proof(operation):
        '''
            Main handler for adding signed order statement to its order proof
        '''
        slot = self.current_slot
        order_statement = generate_order_statement(slot, operation)
        signed_order_statement = sign_order_statement(order_statement)
        add_to_order_proof(signed_order_statement)

    def update_history(slot, operation, order_proof):
        history_statement = generate_history_statement(slot,
                                                       operation, order_proof)
        add_to_history(history_statement)

    def wait_for_result_shuttle(checksum):
        '''
            Replica change their result shuttle waiting status to True
        '''
        waiting_for_result_shuttle[checksum] = True

    def dispatch_shuttle_message(shuttle_message):
        '''
            Method for dispatching shuttle message to next replica
        '''
        print(self, 'sending shuttle message to ', next_replica)
        logger.info(
            '{0} sending shuttle message to {1}'.format(
                self, next_replica))
        send((SHUTTLE, shuttle_message), to=next_replica)
        await(False)

    def check_order_proof_validity(order_proof_list):
        '''
            Method for checking if all slot numbers are
            the same and all hashes are consistent
            It returns False as soon as it notices some inconsistency
        '''
        slot = None
        operation = None
        for order_statement in order_proof_list:
            signature, statement, replica_id = order_statement
            _, statement_slot, statement_operation = statement
            statement_hash = SHA256.new(
                json.dumps(statement).encode('utf-8')).digest()
            public_key = self.public_keys[replica_id]
            if(public_key.verify(statement_hash, signature)):
                if slot is None:
                    _, slot, operation = statement
                else:
                    if slot != statement_slot or \
                            operation != statement_operation:
                        return False
            else:
                logger.error('Order proof verification failed')
                print('Order proof verification failed ',
                      replica_id)
        return True

    def populate_order_proof(order_proof_list):
        '''
            Adds all the order_proof statments from
            shuttle message into its order proof
        '''
        for order_statement in order_proof_list:
            self.order_proof.append(order_statement)

    def populate_result_proof(result_proof_list):
        '''
            Adds all the result_proof statments from
            shuttle message into its result proof
        '''
        for result_statement in result_proof_list:
            self.result_proof.append(result_statement)

    def check_result_proof_validity(result_proof_list):
        '''
            This checks the result proof validity in the
            normal shuttle message(dispatched from head)
        '''
        logger.info(
            'Checking result proof validity of {0}'.format(result_proof_list))
        hashed_running_state = compute_running_state_hash()
        for result_statement in result_proof_list:
            # (signature, ('result', result_hash, status), replica_id)
            signature, statement, replica_id = result_statement
            _, result_hash, _ = statement
            # for validating if the correct sender has sent the message
            hashed_statement = SHA256.new(
                json.dumps(statement). encode('utf-8')).digest()
            public_key = self.public_keys[replica_id]
            if public_key.verify(hashed_statement, signature):
                if hashed_running_state != result_hash:
                    print(result_proof_list)
                    logger.error('Result proof is INCONSISTENT')
                    print('>>>>>>>>Result proof is INCONSISTENT')
                    return False
            else:
                return False  # wrong sender
        return True

    def validate_client_signature(signed_message):
        '''
            Crisp method to verify clients authenticity
        '''
        signature, nonce, client_id = signed_message
        pub_client = self.client_keys[client_id]
        if pub_client.verify(nonce, signature):
            return True
        return False


    def receive(
            msg=(
                'client-request',
                client_payload,
                client_signature),
            from_=c):
        '''
            Client request operation handler.
        '''
        if validate_client_signature(client_signature) and self.mode != REPLICA_IMMUTABLE:
            operation = {}
            operation['client_id'] = client_payload['client_id']
            operation['request_id'] = client_payload['request_number']
            operation['opr'] = client_payload['opr']
            operation['payload'] = {}
            operation['payload']['key'] = client_payload['payload']['key']
            operation['payload']['value'] = client_payload['payload']['value']
            client_info = (operation['client_id'], operation['request_id'])
            checkpoint_count += 1
            if checkpoint_count % checkpoint_limit == 0:
                print('the checkpoint count is ', checkpoint_count, checkpoint_limit)
                checkpoint_statement = generate_checkpoint_statement()
                signed_checkpoint_msg = generate_signed_checkpoint_message(checkpoint_statement)
                print('{0} sending checkpoint to {1} {2}'.format(self, next_replica, [signed_checkpoint_msg]))
                send(('checkpoint', [signed_checkpoint_msg]), to=next_replica)
                checkpoint_count = 1
            handle_operation(operation, client_info)

    def generate_signed_checkpoint_message(checkpoint_statement):
        chkpnt_stm = json.dumps(checkpoint_statement).encode('utf-8')
        chkpnt_statement_hash = SHA256.new(chkpnt_stm).digest()
        signature = self.passport.sign(chkpnt_statement_hash , '')
        return (signature, checkpoint_statement, self.unique_id)

    def generate_checkpoint_statement():
        checkpoint_msg = (compute_running_state_hash(), self.current_slot)
        return checkpoint_msg

    def check_failure(type_failure, payload):
        '''
            This is responsible for updating the failure status.
            It iterates through the failure lists and checks if
            that client and request number matches to trigger the failure.
        '''
        for failure_tuple in self.failures:
            if type_failure in failure_tuple:
                _, from_which_client, \
                    message_number, action = failure_tuple
                # extract message number and client id from the payload
                # then check the index of the client id in the client list and
                # try matching it with the client mentioned in the failure
                client_id = payload[SHUTTLE_CLIENT_ID]
                try:
                    req_id = payload['request_id']
                except KeyError:
                    try:
                        req_id = payload[CLIENT_REQUEST_ID]
                    except KeyError:
                        req_id = payload['request_number']
                client_process = self.clients[client_id]
                if type_failure == 'forwarded_request':
                    if self.failure_forward_request_number[client_id] == \
                            message_number and \
                            self.client_list.index(client_process) == \
                            from_which_client:
                        logger.info('A failure has been scheduled to run next')
                        print('AAAAAAAAAAAAAAAAAAA triggering forwarded request failure next')
                        failure_trigger_dict[action] = True
                elif req_id == message_number and \
                        self.client_list.index(client_process) == \
                        from_which_client:
                    logger.info(
                        'Scheduled failure during {0}'.format(type_failure))
                    print('Scheduled failure action during ',
                          type_failure, ' and the client index is ',
                          from_which_client, ' and for request number ',
                          req_id)
                    failure_trigger_dict[action] = True

    def receive(msg=('shuttle', payload), from_=prev_replica):
        '''
            Shuttle message handler.
            Replica on receiving this performs the operation after validating
            result and order proof.

            It also contains failure trigger points which tries to update the
            failure status.

            When the replica is tail, it sends the result to the client and
            dispatches the result shuttle back to its previous replica.

            Replica change their mode to IMMUTABLE if validation fails
        '''
        shuttle_msg = payload

        if self.current_slot + 1 == shuttle_msg[SHUTTLE_SLOT] and self.mode != REPLICA_IMMUTABLE:  # new slot
            if self.failures is not None:
                check_failure('shuttle', payload)

            order_proof_shuttle = shuttle_msg[SHUTTLE_ORDER_PROOF]
            order_proof_is_valid = check_order_proof_validity(
                order_proof_shuttle)
            if order_proof_is_valid:
                operation = shuttle_msg[SHUTTLE_OPERATION]
                update_current_slot_number()
                status = perform_operation(operation)
                if failure_trigger_dict[CHANGE_OPERATION]:
                    failure_trigger_dict[CHANGE_OPERATION] = False
                    logger.info(
                        'Before change_operation(), order proof was {0}'.format(order_proof_shuttle))
                    print('Before change_operation(), order proof was',
                          order_proof_shuttle)
                    operation = _change_operation(operation)
                    logger.info(
                        'change_operation() has changed operation to {0}'.format(operation))
                    print(
                        'CHANGING THE OPERATION TO GET(\'X\') IN SHUTTLE_MESSAGE',
                        operation)
                result_proof_shuttle = shuttle_msg[SHUTTLE_RESULT_PROOF]
                if check_result_proof_validity(result_proof_shuttle):
                    generate_order_proof(operation)
                    populate_order_proof(order_proof_shuttle)
                    generate_result_proof(status)
                    populate_result_proof(result_proof_shuttle)
                    update_history(self.current_slot, operation,
                                   self.order_proof)
                    checksum = shuttle_msg[CHECKSUM]
                    client_id = shuttle_msg[CLIENT_ID]
                    client_request_id = shuttle_msg[CLIENT_REQUEST_ID]
                    wait_for_result_shuttle(checksum)
                    shuttle_msg = generate_shuttle_message(
                        self.result_proof,
                        self.order_proof,
                        self.current_slot,
                        operation,
                        checksum,
                        client_id,
                        client_request_id)
                    if self.isTail:
                        result_shuttle_msg = shuttle_msg
                        result_shuttle_msg[RESULT] = self.running_state
                        result_shuttle_msg[STATUS] = status
                        if failure_trigger_dict[CHANGE_RESULT]:
                            failure_trigger_dict[CHANGE_RESULT] = False
                            wrong_result_statement = _change_result(
                                result_shuttle_msg[SHUTTLE_RESULT_PROOF])
                            result_shuttle_msg[
                                SHUTTLE_RESULT_PROOF] = wrong_result_statement
                            self.result_proof = wrong_result_statement
                            logger.info('Changing the result to hash(ok) at \
                                    tail {0}'.format(self.result_proof))
                            print(
                                'CHANGING THE RESULT TO HASH(OK) AT TAIL',
                                self.result_proof)

                        if failure_trigger_dict[DROP_RESULT_STMT]:
                            failure_trigger_dict[DROP_RESULT_STMT] = False
                            dropped_result_proof = _drop_result_stmt(
                                result_shuttle_msg[SHUTTLE_RESULT_PROOF])
                            result_shuttle_msg[
                                SHUTTLE_RESULT_PROOF] = dropped_result_proof
                            self.result_proof = dropped_result_proof
                            logger.info(
                                'Dropping the head statement at tail {0}'.format(
                                    self.result_proof))
                            print(
                                'DROPPING THE HEAD AT TAIL',
                                self.result_proof)

                        # COMMENT THIS FOR FORWARDED REQUEST
                        self.result_shuttle_cache[
                            checksum] = result_shuttle_msg
                        # print('arrived at the tail and sending to ', self.clients[client_id], ' answer ', self.running_state)
                        send(('result',
                              (self.running_state,
                               self.result_proof,
                               status,
                               client_request_id)),
                             to=self.clients[client_id])
                        logger.info('Shuttle has arrived at tail.\
                                Running state: {0}'.format(str(self.running_state)))
                        # time.sleep(10)  Uncomment this for forwarded_request
                        send(('result_shuttle', result_shuttle_msg),
                             to=prev_replica)
                    else:
                        dispatch_shuttle_message(shuttle_msg)
                else:
                    logger.error('Replica becomes immutable as result \
                            proof validation failed')
                    print('Replica becomes immutable as result \
                            proof validation failed')
                    self.mode = REPLICA_IMMUTABLE
                    print(self, 'here1')
                    send(('reconfigure-request'), to=olympus)
            else:
                logger.error('Replica becomes immutable as order \
                        proof validation failed')
                print('Replica becomes immutable as order \
                        proof validation failed')
                self.mode = REPLICA_IMMUTABLE
                print(self, 'here2')
                send(('reconfigure-request'), to=olympus)
        else:
            if self.mode != REPLICA_IMMUTABLE:
                self.mode = REPLICA_IMMUTABLE
                send(('reconfigure-request'), to=olympus)

    def validate_complete_result_shuttle(complete_result_proof):
        '''
            This is a method to validate if all the result statements
            are consistent in the result shuttle message
        '''
        result_digest = None
        for result_statement in complete_result_proof:
            signature, statement, replica_id = result_statement
            _, result_hash, _ = statement  # ('result', result_hash, status)
            if result_digest is None:
                result_digest = result_hash
            # for validating if the correct sender has sent the message
            hashed_statement = SHA256.new(
                json.dumps(statement). encode('utf-8')).digest()
            public_key = self.public_keys[replica_id]
            if public_key.verify(hashed_statement, signature):
                if result_digest != result_hash:
                    return False
            else:
                return False  # The result_statement has been changed because of failure injection
        return True

    def receive(msg=('die-now', nothing), from_=next_replica):
        self.replica_life = True
        logger.info('The value of self.replica_life has been changed to {0}'.format(self.replica_life))
        import os
        os._exit(1)

    def receive(msg=('result_shuttle', payload), from_=next_replica):
        '''
            This is a result_shuttle message handler.
            On receiving this message, the replica validates it and forwards
            it to its previous replica.
            It also checks if the client has made a
            retransmission request for
            that result, if yes, then it sends it to the client.
            It also saves the result_shuttle in its cache
        '''
        print(self, ': Receiving result shuttle from ', next_replica)
        logger.info(
            '{0}: Receiving result shuttle from {1}'.format(
                self, next_replica))
        complete_result_proof = payload[SHUTTLE_RESULT_PROOF]

        if self.failures is not None:
            check_failure('result_shuttle', payload)

        if validate_complete_result_shuttle(complete_result_proof):
            result_shuttle = payload
            checksum = result_shuttle[CHECKSUM]
            # used during retransmission scenario
            self.result_shuttle_cache[checksum] = result_shuttle
            del self.waiting_for_result_shuttle[checksum]
            if failure_trigger_dict[CHANGE_RESULT]:
                failure_trigger_dict[CHANGE_RESULT] = False
                wrong_result_statement = _change_result(
                    result_shuttle[SHUTTLE_RESULT_PROOF])
                result_shuttle[SHUTTLE_RESULT_PROOF] = wrong_result_statement
                logger.info(
                    'New wrong result stm is {0}'.format(
                        result_shuttle[SHUTTLE_RESULT_PROOF]))
                print(
                    'This is the new wrong result_stm AT RESULT_SHUTTLE',
                    result_shuttle[SHUTTLE_RESULT_PROOF])

            if failure_trigger_dict[DROP_RESULT_STMT]:
                failure_trigger_dict[DROP_RESULT_STMT] = False
                dropped_result_proof = _drop_result_stmt(
                    result_shuttle[SHUTTLE_RESULT_PROOF])
                result_shuttle[SHUTTLE_RESULT_PROOF] = dropped_result_proof
                logger.info(
                    'Dropping the head result statement {0} and head replica id is {1}'.format(
                        dropped_result_proof, head_replica_id))
                print(
                    'DROPPING THE HEAD_RESULT_STMT AT RESULT_SHUTTLE',
                    dropped_result_proof,
                    head_replica_id)

            if checksum in self.retransmission:
                logger.info('Sending the result shuttle to client ')
                print('Sending the result shuttle to client ')
                client_id = self.retransmission[checksum]
                reply_to_client = self.clients[client_id]
                proof = result_shuttle[SHUTTLE_RESULT_PROOF]
                res = result_shuttle[RESULT]
                status = result_shuttle[STATUS]
                client_request_id = result_shuttle[CLIENT_REQUEST_ID]
                send(('result', (res, proof, status, client_request_id)),
                     to=reply_to_client)
                del self.retransmission[checksum]
            if not isHead:
                send(('result_shuttle', result_shuttle), to=prev_replica)
            elif isHead:
                logger.info('Received the complete result_shuttle ')
                print('Received the complete result_shuttle ',
                      len(result_shuttle[SHUTTLE_RESULT_PROOF]))

        else:
            logger.info('Result proof validation is wrong')
            print('RESULT PROOF IS WRONG, GOING TO IMMUTABLE STAGE')
            self.mode = REPLICA_IMMUTABLE
            print(self, 'here4')
            send(('reconfigure-request'), to=olympus)

    def validate_checkpoint(checkpoint_list):
        reference_hashed_state = None
        reference_slot_number = None
        for checkpoint_statement in checkpoint_list:
            signature, statement, replica_id = checkpoint_statement
            hashed_state, checkpoint_slot_number = statement  # (hashed_state, slot number)
            if reference_hashed_state is None:
                reference_hashed_state = hashed_state
            if reference_slot_number is None:
                reference_slot_number = checkpoint_slot_number
            # for validating if the correct sender has sent the message
            hashed_statement = SHA256.new(
                json.dumps(statement). encode('utf-8')).digest()
            public_key = self.public_keys[replica_id]
            if public_key.verify(hashed_statement, signature):
                if reference_hashed_state != hashed_state:
                    return False
            else:
                return False
        return True

    def truncate_history(signed_checkpoint_list):
        # pick any random entry from the list and remove the 
        checkpoint_msg = signed_checkpoint_list[0]
        _, checkpoint_statement, _ = checkpoint_msg
        _, max_slot_to_remove = checkpoint_statement
        print('truncating history', max_slot_to_remove)
        index = -1
        for pos, i in enumerate(self.history):
            if i[0] ==  max_slot_to_remove:
                 index = pos
        if index != -1:
            checkpoint_cache = signed_checkpoint_list
            # print('old history', self.history)
            self.history = self.history[index:]
            # print('new history', self.history)
            print('new history starts from: ', index)

    def receive(msg=('checkpoint', signed_checkpoint_payload), from_=prev_replica):
        if validate_checkpoint(signed_checkpoint_payload):
                checkpoint_statement = generate_checkpoint_statement()
                signed_checkpoint_msg = generate_signed_checkpoint_message(checkpoint_statement)
                signed_checkpoint_payload.append(signed_checkpoint_msg)
                if not isTail:
                    send(('checkpoint', signed_checkpoint_payload), to=next_replica)
                else:
                    truncate_history(signed_checkpoint_payload)
                    send(('checkpoint_proof', signed_checkpoint_payload), to=prev_replica)
        else:
            print('Couldnot verify checkpoint message')

    def receive(msg=('checkpoint_proof', signed_checkpoint_list), from_=next_replica):
        if validate_checkpoint(signed_checkpoint_list):
            truncate_history(signed_checkpoint_list)
            if not isHead:
                send(('checkpoint_proof', signed_checkpoint_list), to=prev_replica)

    def receive(msg=('retransmission', retrans_payload, client_signature),
                from_=c):
        '''
            This is a retransmission handler.
            This method is triggered when client sends a retransmission
            message, or replica forwards the retransmission
            message to the head

            Replica sends error to client if it is in IMMUTABLE stage
            Replica sends result if the result shuttle is present in the
            cache Or else, it forwards the message to head and runs a timeout

            Head replica runs in the same function. It checks if the operation
            is new and also runs a timeout.
        '''
        print('Received retransmission request')
        logger.info('Received retransmission req')
        if not validate_client_signature(client_signature):
            return
        client_info = (retrans_payload['client_id'],
                       retrans_payload['request_number'])
        client_id = retrans_payload['client_id']
        checksum = SHA256.new(json.dumps(client_info).
                              encode('utf-8')).hexdigest()

        if client_id not in self.failure_forward_request_number:
            self.failure_forward_request_number[client_id] = -1
        else:
            self.failure_forward_request_number[client_id] += 1

        check_failure('forwarded_request', retrans_payload)
        check_failure('client_request', retrans_payload)
        if checksum not in self.retransmission:
            # self.retransmission.append(checksum)
            self.retransmission[checksum] = client_info[0]

        if self.mode == REPLICA_IMMUTABLE:
            reply_to_client = self.clients[client_id]
            logger.info('sending error to client as it is immutable')
            send(('error', 'immutable'), to=reply_to_client)

        elif checksum in self.result_shuttle_cache:  # checksum uniquely combines client id and request number
            print(self, 'sending result to client from its\
                    result_proof_cache', checksum)
            logger.info(self, 'sending result to client from \
                    its result_proof cache')
            proof = self.result_shuttle_cache[checksum][SHUTTLE_RESULT_PROOF]
            res = self.result_shuttle_cache[checksum][RESULT]
            status = self.result_shuttle_cache[checksum][STATUS]
            client_request_id = self.result_shuttle_cache[
                checksum][CLIENT_REQUEST_ID]
            reply_to_client = self.clients[client_id]

            # For the next outgoing message
            if self.failure_trigger_dict[CHANGE_RESULT]:
                self.failure_trigger_dict[CHANGE_RESULT] = False
                proof = _change_result(proof)
            if self.failure_trigger_dict[DROP_RESULT_STMT]:
                self.failure_trigger_dict[DROP_RESULT_STMT] = False
                proof = _drop_result_stmt(proof)
            print('send this data to client ', (res, status))
            logger.info(
                'sending this result to client {0}'.format(
                    (res, status)))
            send(('result', (res, proof, status, client_request_id)),
                 to=reply_to_client)
            # after sending the result, remove the entry from retransmission
            del self.retransmission[checksum]
        else:
            if not isHead:
                print('forwarding request to the head')
                logger.info('forwarding request to the head')
                send(('retransmission', retrans_payload), to=head_replica)
                if await(some(received(('result_shuttle', payload)))):
                    print('Retransmission request being processed @nonhead')
                    logger('Retransmission request being processed @nonhead')
                elif timeout(self.timeout_val):
                    print ('Timeout occured at @nonhead')
                    logger.error('Timeout occured at @nonhead')
                    print('Timeout @nonhead: Have to send \
                            reconfigure message to Olympus')
                    logger.error('Timeout @nonhead: Have to send \
                            reconfigure message to Olympus')
                    print(self, 'here4')
                    if self.mode != REPLICA_IMMUTABLE:
                        send(('reconfigure-request'), to=olympus)
            else:
                if not self.waiting_for_result_shuttle[checksum]:
                    # We have create a new slot and perform fresh new operation
                    handle_operation(retrans_payload, client_info)
                if await(some(received(('result_shuttle', payload)))):
                    print('Retransmission request being processed @head')
                    logger.info('Retransmission request being processed @head')
                elif timeout(self.timeout_val):
                    logger.info('Timeout expired at Head: \
                            Have to send reconfigure message to Olympus')
                    print('Timeout expird at Head: \
                            Have to send reconfigure message to Olympus')
                    print(self, 'here5')
                    if self.mode != REPLICA_IMMUTABLE:
                        send(('reconfigure-request'), to=olympus)

    def generate_caughtup_signature(caughtup_statement):
        caughtup_stm = json.dumps(caughtup_statement).encode('utf-8')
        caught_up_statement_hash = SHA256.new(caughtup_stm).digest()
        signature = self.passport.sign(caught_up_statement_hash , '')
        return (signature, caughtup_statement, self.unique_id)

    def receive(msg=('catchup-request', sequence_of_operations), from_=olympus):
        # perform the sequence of operations in the current running state
        # send the hash of the current running state to the olympus
        # send caught up response
        print(self, 'received catchup-request for ', sequence_of_operations)
        for operations in sequence_of_operations:
            slot, opr = operations
            if slot == self.current_slot + 1:
                self.current_slot = slot
                status = perform_operation(opr)
                print(self, 'perfoming {0} {1} => {2}'.format(slot, opr, status))
        caughtup_statement = compute_running_state_hash()
        signed_caughtup_statement = generate_caughtup_signature(caughtup_statement)
        send(('caughtup-response', signed_caughtup_statement), to=olympus)

    def receive(msg=('get-running-state'), from_=olympus):
        send(('running-state', self.running_state), to=olympus)

    def generate_signed_wedge_statement(wedge_statement):
        wedge_stm = json.dumps(wedge_statement).encode('utf-8')
        wedge_statement_hash = SHA256.new(wedge_stm).digest()
        signature = self.passport.sign(wedge_statement_hash , '')
        return (signature, wedge_statement, self.unique_id)

    def generate_wedge_statement():
        wedge_statement = (self.checkpoint_cache, self.history)
        return wedge_statement

    def receive(msg=('wedge-request'), from_=olympus):
        # validate if it came from the olympus: TODO
        print(self, ' receiving wedge req')
        self.mode = REPLICA_IMMUTABLE
        wedge_statement = generate_wedge_statement()
        signed_wedge_message = generate_signed_wedge_statement(wedge_statement)
        # if not self.isTail:
        send(('wedge-response', signed_wedge_message), to=olympus)

    def generate_client_result_message(result_shuttle):
        '''
            This crafts a result for the client
        '''
        complete_result_proof = result_shuttle[SHUTTLE_RESULT_PROOF]
        final_result = result_shuttle[RESULT]
        return json.dumps((final_result, complete_result_proof))\
            .encode('utf-8')

    def generate_shuttle_message(result_proof, order_proof, slot,
                                 operation, checksum, client_id, request_id):
        '''
            This is a method to generate shuttle message
        '''
        shuttle_msg = {}
        shuttle_msg[SHUTTLE_RESULT_PROOF] = result_proof
        shuttle_msg[SHUTTLE_ORDER_PROOF] = order_proof
        shuttle_msg[SHUTTLE_SLOT] = slot
        shuttle_msg[SHUTTLE_OPERATION] = operation
        shuttle_msg[CHECKSUM] = checksum
        shuttle_msg[CLIENT_ID] = client_id
        shuttle_msg[CLIENT_REQUEST_ID] = request_id
        return shuttle_msg

    def test_dict_object():
        _put(('movie', 'star'))
        _append(('movie', ' wars'))
        _get('movie')
        _slice(('movie', '0:2'))
        print(self.running_state)


def main():
    config(clock='Lamport')
    random_generator = Random.new().read

    replica1 = new(Replica, num=1)
    replica2 = new(Replica, num=1)
    replica3 = new(Replica, num=1)
    replica4 = new(Replica, num=1)

    key1 = RSA.generate(1024, random_generator)
    key2 = RSA.generate(1024, random_generator)
    key3 = RSA.generate(1024, random_generator)
    key4 = RSA.generate(1024, random_generator)

    unique_id_1 = uuid.uuid4().hex
    unique_id_2 = uuid.uuid4().hex
    unique_id_3 = uuid.uuid4().hex
    unique_id_4 = uuid.uuid4().hex

    keychain1 = {
        unique_id_2: key2.publickey().exportKey(),
        unique_id_3: key3.publickey().exportKey(),
        unique_id_4: key4.publickey().exportKey(),
        unique_id_1: key1.publickey().exportKey()
    }
    keychain2 = {
        unique_id_1: key1.publickey().exportKey(),
        unique_id_3: key3.publickey().exportKey(),
        unique_id_4: key4.publickey().exportKey(),
        unique_id_2: key2.publickey().exportKey()
    }
    keychain3 = {
        unique_id_1: key1.publickey().exportKey(),
        unique_id_2: key2.publickey().exportKey(),
        unique_id_4: key4.publickey().exportKey(),
        unique_id_3: key3.publickey().exportKey()
    }
    keychain4 = {
        unique_id_1: key1.publickey().exportKey(),
        unique_id_2: key2.publickey().exportKey(),
        unique_id_3: key3.publickey().exportKey(),
        unique_id_4: key4.publickey().exportKey()
    }

    client_dict = {}

    setup(
        replica1,
        (True,
         False,
         unique_id_1,
         None,
         replica2,
         key1,
         keychain1,
         None,
         replica1,
         client_dict,
         10,
         None,
         unique_id_1))
    setup(
        replica2,
        (False,
         False,
         unique_id_2,
         replica1,
         replica3,
         key2,
         keychain2,
         None,
         replica1,
         client_dict,
         10,
         None,
         unique_id_1))
    setup(
        replica3,
        (False,
         False,
         unique_id_3,
         replica2,
         replica4,
         key3,
         keychain3,
         None,
         replica1,
         client_dict,
         10,
         None,
         unique_id_1))
    setup(
        replica4,
        (False,
         True,
         unique_id_4,
         replica3,
         None,
         key4,
         keychain4,
         None,
         replica1,
         client_dict,
         10,
         None,
         unique_id_1))

    start(replica1)
    start(replica2)
    start(replica3)
    start(replica4)
