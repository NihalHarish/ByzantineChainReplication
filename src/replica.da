import uuid, json
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA
from Crypto import Random
import time
import logging
import os
from constants import  (RESULT_SHUTTLE_FAILURE_TRIGGER, CLIENT_REQUEST_FAILURE_TRIGGER, SHUTTLE_FAILURE_TRIGGER, FORWARDED_FAILURE_TRIGGER, CHANGE_OPERATION_FAILURE, CHANGE_RESULT_FAILURE,DROP_RESULT_FAILURE)


# Replica States
REPLICA_PENDING = 'PENDING'
REPLICA_ACTIVE = 'ACTIVE'
REPLICA_IMMUTABLE = 'IMMUTABLE'


# Shuttle message keys
SHUTTLE_RESULT_PROOF = 'result_proof'
SHUTTLE_ORDER_PROOF = 'order_proof'
SHUTTLE_SLOT = 'slot'
SHUTTLE_OPERATION = 'operation'
SHUTTLE_CHECKSUM = 'checksum'
SHUTTLE_CLIENT_ID = 'client_id'
SHUTTLE = 'shuttle'

CHECKSUM = 'checksum'
CLIENT_ID = 'client_id'
CLIENT_REQUEST_ID = 'client_request_id'

RESULT_SHUTTLE = 'fuckthisshit'  # TODO: PROFANITY ALERT
RESULT = 'result'

STATUS = 'status'

class Replica(process):
    def setup(isHead: bool, isTail: bool, unique_id: str, prev_replica: Replica, next_replica: Replica, key: instance, keychain: dict, clients_list: instance, head: Replica, clients: dict, timeout_val: int, client_keys: dict, failures: None):
        self.unique_id = unique_id
        self.running_state = {}
        self.history = []
        self.result_proof = []
        self.order_proof = []

        self.mode = REPLICA_ACTIVE
        self.prev_replica = prev_replica
        self.next_replica = next_replica
        self.public_keys = {}
        self.private_key = None
        self.result_shuttle_cache = {}
        self.checkpoint_proof_cache = {}
        self.isHead = isHead
        self.isTail = isTail
        self.current_slot = 0
        self.config_number = 1
        self.retransmission = {}
        self.waiting_for_result_shuttle = {}
        self.passport = key
        self.operations_dispatcher = {
            'put' : self._put,
            'append': self._append,
            'slice' : self._slice,
            'get' :self._get
        }
        _build_key_chain(keychain)
        self.client_list = clients_list
        self.head_replica = head
        self.logger = None
        self.clients = clients  # dict: key: client uuid, value: client object
        self.client_keys = client_keys
        self.timeout_val = timeout_val
        self.failures = failures  # [(failure_trigger_msg, from_which_client, message_number, failure_action)]
        print (self, ' FAILURES: ', failures)


    def _build_key_chain(keychain):
        for replica_id, public_key in keychain.items():
            self.public_keys[replica_id] = RSA.importKey(public_key)

    '''
        Dictionary Operations

    '''

    def _put(params):
        key = params['key']
        value = params['value']
        self.running_state[key] = value
        return 'OK'


    def _append(params):
        key = params['key']
        new_value = params['value']
        if key in self.running_state:
            early_value = self.running_state[key]
            self.running_state[key] = early_value + new_value
            return 'OK'
        else:
            return 'fail'


    def _get(params):
        key = params['value']
        if key in self.running_state:
            return self.running_state[key]
        return 'fail'


    def _slice(params):
        key = params['key']
        value = params['value']
        if key in self.running_state:
            early_value = self.running_state[key]
            start, end = value.split(':')
            if start == '' and end != '':
                end = int(end)
                self.running_state[key] = early_value[: end]
            elif start != '' and end == '':
                start = int(start)
                self.running_state[key] = early_value[start:]
            else:
                start =  int(start)
                end = int(end)
                if end > start:
                    self.running_state[key] = early_value[start:end]
                else:
                    return 'fail'
            return 'OK'
        else:
            return 'fail'

    def init_logger():
        logging_directory = os.path.join(os.path.dirname(os.path.abspath(__file__)),'../logs/')
        logger = logging.getLogger(os.path.join(logging_directory, 'replica_{0}'.format(unique_id)))
        logger.setLevel(logging.INFO)
        fh = logging.FileHandler(os.path.join(logging_directory, 'replica_{0}.log'.format(unique_id)))
        fh.setLevel(logging.INFO)
        #ch = logging.StreamHandler()
        #ch.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        #ch.setFormatter(formatter)
        fh.setFormatter(formatter)
        #logger.addHandler(ch)
        logger.addHandler(fh)

    def run():
        init_logger()
        #logging.info("Replica is running")
        logger.info('REPLICA IS RUNNING DUDE')
        print("REPLICA IS RUNNING")
        await(False)


    def update_current_slot_number():
        self.current_slot += 1


    def compute_running_state_hash():
        running_state_json = json.dumps(self.running_state).encode('utf-8')
        return SHA256.new(running_state_json).hexdigest()


    def generate_result_statement(result_hash, status):
        statement = ('result', result_hash, status)  # adds status also
        return statement


    def sign_result_statement(result_statement):  # ('result', result_hash, status)
        result_stm = json.dumps(result_statement).encode('utf-8')
        result_statement_hash = SHA256.new(result_stm).digest()
        signature = self.passport.sign(result_statement_hash, '')
        return (signature, result_statement, self.unique_id)  # TODO: add the response_status here


    def add_to_result_proof(signed_result_proof):
        self.result_proof = []
        self.result_proof.append(signed_result_proof)


    def generate_order_statement(slot, operation):
        order_statement = ('order', slot, operation)
        return order_statement


    def sign_order_statement(order_statement):
        order_stm = json.dumps(order_statement).encode('utf-8')
        order_statement_hash = SHA256.new(order_stm).digest()
        signature = self.passport.sign(order_statement_hash, '')
        return (signature, order_statement, self.unique_id)


    def add_to_order_proof(signed_order_statement):
        self.order_proof = []  # TODO: Added this new
        self.order_proof.append(signed_order_statement)


    def generate_history_statement(slot, operation, order_proof):  # TODO
        history_statement = json.dumps((slot, operation, order_proof))
        return history_statement


    def add_to_history(history_statement):
        self.history.append(history_statement)


    def perform_operation(operation):
        '''
            opr: put/get/append/slice
            payload: {
                key, value
            }
        '''
        opr = operation['opr']
        payload = operation['payload']
        if opr == 'put' or opr =='append' or opr == 'slice' or opr == 'get':
            status = self.operations_dispatcher[opr](payload)
            return status
        return 'fail'


    def handle_operation(operation, client_info):
        if self.isHead:
            if self.failures is not None:
                check_failure('client_request', operation)
            update_current_slot_number()
            status = perform_operation(operation)
            generate_result_proof(status)
            generate_order_proof(operation)
            update_history(self.current_slot, operation, self.order_proof)
            client_id, client_request_id = client_info
            client_info_checksum = SHA256.new(json.dumps(client_info).encode('utf-8')).hexdigest()
            wait_for_result_shuttle(client_info_checksum)
            shuttle_msg = generate_shuttle_message(self.result_proof, self.order_proof, self.current_slot, operation, client_info_checksum, client_id, client_request_id)
            dispatch_shuttle_message(shuttle_msg)


    def generate_result_proof(status):
        #_put(('movie', 'Bangalore Days'))
        result_hash = compute_running_state_hash()
        result_statement = generate_result_statement(result_hash, status)
        signed_result_statement = sign_result_statement(result_statement)
        add_to_result_proof(signed_result_statement)


    def generate_order_proof(operation):
        slot = self.current_slot
        #operation = 'put(\'movie\':\'Bangalore Days\')'
        order_statement = generate_order_statement(slot, operation)
        signed_order_statement = sign_order_statement(order_statement)
        add_to_order_proof(signed_order_statement)


    def update_history(slot, operation, order_proof):
        history_statement = generate_history_statement(slot, operation, order_proof)  # TODO: add replica_id and config number
        add_to_history(history_statement)


    def wait_for_result_shuttle(checksum):
        waiting_for_result_shuttle[checksum] = True


    def dispatch_shuttle_message(shuttle_message):
        print(self, 'sending shuttle message to ', next_replica)
        #logging.info(str(self)+ ' sending shuttle message to ' +  str(next_replica))
        #logging.info('dispatch shuttle message')
        logger.info('dispatch shuttle message')
        send((SHUTTLE, shuttle_message), to=next_replica)
        await(False) #  TODO: This needs to wait till it receives a complete result proof from its next replica


    def check_order_proof_validity(order_proof_list):
        slot = None
        operation = None
        for order_statement in order_proof_list:
            signature, statement, replica_id = order_statement
            _, statement_slot, statement_operation = statement
            statement_hash = SHA256.new(json.dumps(statement).encode('utf-8')).digest()
            public_key = self.public_keys[replica_id]
            if(public_key.verify(statement_hash, signature)):
                if slot is None:
                    _, slot, operation = statement
                else:
                    if slot != statement_slot or operation != statement_operation:
                        return False
            else:
                print('it messed up big')

        return True


    def populate_order_proof(order_proof_list):
        for order_statement in order_proof_list:
            self.order_proof.append(order_statement)


    def populate_result_proof(result_proof_list):
        for result_statement in result_proof_list:
            self.result_proof.append(result_statement)


    def check_result_proof_validity(result_proof_list):
        #print(self, result_proof_list)
        hashed_running_state = compute_running_state_hash()
        for result_statement in result_proof_list:
            signature, statement, replica_id = result_statement  # (signature, ('result', result_hash, status), replica_id)
            _, result_hash, _ = statement
            hashed_statement = SHA256.new(json.dumps(statement).encode('utf-8')).digest()  # for validating if the correct sender has sent the message 
            public_key = self.public_keys[replica_id]
            if public_key.verify(hashed_statement, signature):
                if hashed_running_state != result_hash:
                    return False
            else:
                return False  # wrong sender
        return True

    def validate_client_signature(signed_message):
        signature, nonce, client_id = signed_message
        pub_client = self.client_keys[client_id]
        if pub_client.verify(nonce, signature):
            return True
        return False


    def receive(msg=('please_work', client_payload, client_signature), from_=c):  # TODO: Failure injection
        if validate_client_signature(client_signature):
            operation = {}
            operation['client_id'] = client_payload['client_id']
            operation['request_id'] = client_payload['request_number']
            operation['opr'] = client_payload['opr']
            operation['payload'] = {}
            operation['payload']['key'] = client_payload['payload']['key']
            operation['payload']['value'] = client_payload['payload']['value']
            client_info = (operation['client_id'], operation['request_id'])
            handle_operation(operation, client_info)


    def check_failure(type_failure, payload):
        if type_failure == 'shuttle' or type_failure == 'result_shuttle' or type_failure == 'client_request':
            for failure_tuple in self.failures:
                if type_failure in failure_tuple:
                    _, from_which_client, message_number, action = failure_tuple
                    # extract message number and client id from the payload
                    # then check the index of the client id in the client list and try matching it with the client mentioned in the failure
                    client_id = payload[SHUTTLE_CLIENT_ID]
                    try:
                        req_id = payload['request_id']
                    except KeyError:
                        req_id = payload[CLIENT_REQUEST_ID]
                    client_process = self.clients[client_id]
                    if req_id == message_number and self.client_list.index(client_process) == from_which_client:
                        print('trigger the freaking action man ', action, ' and the client index is ', from_which_client, ' and for request number ', req_id, self.isHead)
                        return True



    def receive(msg=('shuttle', payload), from_=prev_replica):
        shuttle_msg = payload


        if self.current_slot+1 == shuttle_msg[SHUTTLE_SLOT]:  # new slot
            if self.failures is not None:
                check_failure('shuttle', payload)  # TODO: adding shuttle failure
            order_proof_shuttle = shuttle_msg[SHUTTLE_ORDER_PROOF]
            order_proof_is_valid = check_order_proof_validity(order_proof_shuttle)
            if order_proof_is_valid:
                operation = shuttle_msg[SHUTTLE_OPERATION]
                update_current_slot_number()
                status = perform_operation(operation)
                result_proof_shuttle = shuttle_msg[SHUTTLE_RESULT_PROOF]
                if check_result_proof_validity(result_proof_shuttle):
                    generate_order_proof(operation)
                    populate_order_proof(order_proof_shuttle)
                    generate_result_proof(status)
                    populate_result_proof(result_proof_shuttle)
                    update_history(self.current_slot, operation, self.order_proof)
                    checksum = shuttle_msg[CHECKSUM]
                    client_id = shuttle_msg[CLIENT_ID]
                    client_request_id = shuttle_msg[CLIENT_REQUEST_ID]
                    wait_for_result_shuttle(checksum)
                    shuttle_msg = generate_shuttle_message(self.result_proof, self.order_proof, self.current_slot, operation, checksum, client_id, client_request_id)
                    if self.isTail:
                        result_shuttle_msg = shuttle_msg
                        result_shuttle_msg[RESULT] = self.running_state
                        result_shuttle_msg[STATUS] = status
                        self.result_shuttle_cache[checksum] = result_shuttle_msg  # used during retransmission scenario
                        # Send message back to client
                        # print('arrived at the tail and sending to ', self.clients[client_id], ' answer ', self.running_state)
                        send(('result', (self.running_state, self.result_proof, status, client_request_id)), to=self.clients[client_id])
                        logger.info('Shuttle has arrived at tail. Running state: ' +str(self.running_state))
                        send(('result_shuttle', result_shuttle_msg), to=prev_replica)
                    else:
                        dispatch_shuttle_message(shuttle_msg)
                else:
                    self.mode = REPLICA_IMMUTABLE
            else:
                self.mode = REPLICA_IMMUTABLE
        else:
            self.mode = REPLICA_IMMUTABLE


    def validate_complete_result_shuttle(complete_result_proof):
        #print(complete_result_proof)
        result_digest = None
        for result_statement in complete_result_proof:
            signature, statement, replica_id = result_statement
            _, result_hash, _ = statement  # ('result', result_hash, status)
            if result_digest is None:
                result_digest = result_hash
            hashed_statement = SHA256.new(json.dumps(statement).encode('utf-8')).digest()  # for validating if the correct sender has sent the message 
            public_key = self.public_keys[replica_id]
            if public_key.verify(hashed_statement, signature):
                if result_digest != result_hash:
                    return False
        return True


    def receive(msg=('result_shuttle', payload), from_=next_replica):
        print(self, ': Receiving result shuttle')
        #logging.info(str(self) + ': Receiving result shuttle')
        logger.info(str(self) + ': Receiving result shuttle')
        complete_result_proof = payload[SHUTTLE_RESULT_PROOF]

        if self.failures is not None:
            check_failure('result_shuttle', payload)

        if validate_complete_result_shuttle(complete_result_proof):
            result_shuttle = payload
            checksum = result_shuttle[CHECKSUM]
            self.result_shuttle_cache[checksum] = result_shuttle  # used during retransmission scenario
            del self.waiting_for_result_shuttle[checksum]
            # TODO: If the checksum is present in retransmission: send the result_shuttle to the client directly
            if checksum in self.retransmission:
                print('the checksum is present in retransmission, will have to send the message to client')
                client_id = self.retransmission[checksum]
                reply_to_client = self.clients[client_id]
                proof = result_shuttle[SHUTTLE_RESULT_PROOF]
                res = result_shuttle[RESULT]
                status = result_shuttle[STATUS]
                client_request_id = result_shuttle[CLIENT_REQUEST_ID]
                send(('result', (res, proof, status, client_request_id)), to=reply_to_client)
                del self.retransmission[checksum]
            if not isHead:
                send(('result_shuttle', result_shuttle), to=prev_replica)
            elif isHead:
                print('Received the complete result_shuttle ')


    def receive(msg=('retransmission', retrans_payload, client_signature), from_=c):
        print('Received retransmission request')
        if not validate_client_signature(client_signature):
            return
        client_info = (retrans_payload['client_id'], retrans_payload['request_number'])
        client_id = retrans_payload['client_id']
        checksum = SHA256.new(json.dumps(client_info).encode('utf-8')).hexdigest()

        if checksum not in self.retransmission:
            # self.retransmission.append(checksum)
            self.retransmission[checksum] = client_info[0]  # TODO: Sorry, add id of the client to the checksum

        if self.mode == REPLICA_IMMUTABLE:
            # send(('error','immutable'), to=c)  # TODO: make sure that error message is sent to the client only
            reply_to_client = self.clients[client_id]
            send(('error', 'immutable'), to=reply_to_client)

        elif checksum in self.result_shuttle_cache:  # checksum uniquely combines client id and request number
            print(self, 'sending data to client from its cache', checksum)
            proof = self.result_shuttle_cache[checksum][SHUTTLE_RESULT_PROOF]
            res = self.result_shuttle_cache[checksum][RESULT]
            status = self.result_shuttle_cache[checksum][STATUS]
            client_request_id = self.result_shuttle_cache[checksum][CLIENT_REQUEST_ID]
            reply_to_client = self.clients[client_id]
            print('send this data to client ', (res, status))
            send(('result', (res, proof, status, client_request_id)), to=reply_to_client)  # TODO: send status to the client
            del self.retransmission[checksum]  # after sending the result, remove the entry from retransmission
            # TODO: Problem: Head might receive this from replicas as well.. so it should make sure, that the head delivers the message to client
        else:                              # TODO: This part is completely messed up.. especially about cancelling timers
            if not isHead:
                print (self, 'good lord, checksum is not present ', checksum, self.isTail)
                print('forwarding request to the head')
                send(('retransmission', retrans_payload), to=head_replica)
                if await(some(received(('result_shuttle', payload)))):
                    print('Retransmission request being processed @nonhead')
                elif timeout(self.timeout_val):
                    print ('this happens at @nonhead')
                    print('Have to send reconfigure message to Olympus')
            else:
                if not self.waiting_for_result_shuttle[checksum]:
                    # We have create a new slot and perform fresh new operation
                    handle_operation(retrans_payload, client_info)
                if await(some(received(('result_shuttle', payload)))):
                    print('Retransmission request being processed @head')
                elif timeout(self.timeout_val):
                    print ('this happens at @head')
                    print('Have to send reconfigure message to Olympus')



    def generate_client_result_message(result_shuttle):
        complete_result_proof = result_shuttle[SHUTTLE_RESULT_PROOF]
        final_result = result_shuttle[RESULT]
        return json.dumps((final_result, complete_result_proof)).encode('utf-8')


    def generate_shuttle_message(result_proof, order_proof, slot, operation, checksum, client_id, request_id):
        shuttle_msg = {}
        shuttle_msg[SHUTTLE_RESULT_PROOF] = result_proof
        shuttle_msg[SHUTTLE_ORDER_PROOF] = order_proof
        shuttle_msg[SHUTTLE_SLOT] = slot
        shuttle_msg[SHUTTLE_OPERATION] = operation
        shuttle_msg[CHECKSUM] = checksum
        shuttle_msg[CLIENT_ID] = client_id
        shuttle_msg[CLIENT_REQUEST_ID] = request_id
        return shuttle_msg


    def test_dict_object():
        _put(('movie', 'star'))
        _append(('movie', ' wars'))
        _get('movie')
        _slice(('movie', '0:2'))
        print(self.running_state)



def main():
    config(clock='Lamport')
    random_generator = Random.new().read

    replica1 = new(Replica, num=1)
    replica2 = new(Replica, num=1)
    replica3 = new(Replica, num=1)
    replica4 = new(Replica, num=1)

    key1 = RSA.generate(1024, random_generator)
    key2 = RSA.generate(1024, random_generator)
    key3 = RSA.generate(1024, random_generator)
    key4 = RSA.generate(1024, random_generator)

    unique_id_1 = uuid.uuid4().hex
    unique_id_2 = uuid.uuid4().hex
    unique_id_3 = uuid.uuid4().hex
    unique_id_4 = uuid.uuid4().hex


    keychain1 = {unique_id_2: key2.publickey().exportKey(), unique_id_3: key3.publickey().exportKey(), unique_id_4: key4.publickey().exportKey(), unique_id_1: key1.publickey().exportKey()}
    keychain2 = {unique_id_1: key1.publickey().exportKey(), unique_id_3: key3.publickey().exportKey(), unique_id_4: key4.publickey().exportKey(), unique_id_2: key2.publickey().exportKey()}
    keychain3 = {unique_id_1: key1.publickey().exportKey(), unique_id_2: key2.publickey().exportKey(), unique_id_4: key4.publickey().exportKey(), unique_id_3: key3.publickey().exportKey()}
    keychain4 = {unique_id_1: key1.publickey().exportKey(), unique_id_2: key2.publickey().exportKey(), unique_id_3: key3.publickey().exportKey(), unique_id_4: key4.publickey().exportKey()}


    client_dict = {}

    setup(replica1, (True, False, unique_id_1, None, replica2, key1, keychain1, None, replica1, client_dict, 10, None))
    setup(replica2, (False, False, unique_id_2, replica1, replica3, key2, keychain2, None, replica1, client_dict, 10, None))
    setup(replica3, (False, False, unique_id_3, replica2, replica4, key3, keychain3, None, replica1, client_dict, 10, None))
    setup(replica4, (False, True, unique_id_4, replica3, None, key4, keychain4, None, replica1, client_dict, 10, None))


    start(replica1)
    start(replica2)
    start(replica3)
    start(replica4)
