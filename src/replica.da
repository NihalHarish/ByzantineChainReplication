import uuid, json
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA
from Crypto import Random
import time

# Replica States
REPLICA_PENDING = 'PENDING'
REPLICA_ACTIVE = 'ACTIVE'
REPLICA_IMMUTABLE = 'IMMUTABLE'


# Shuttle message keys
SHUTTLE_RESULT_PROOF = 'result_proof'
SHUTTLE_ORDER_PROOF = 'order_proof'
SHUTTLE_SLOT = 'slot'
SHUTTLE_OPERATION = 'operation'
SHUTTLE_CHECKSUM = 'checksum'
SHUTTLE_CLIENT_ID = 'client_id'
SHUTTLE = 'shuttle'

CHECKSUM = 'checksum'
CLIENT_ID = 'client_id'

RESULT_SHUTTLE = 'fuckthisshit'
RESULT = 'result'

class Replica(process):
    def setup(isHead: bool, isTail: bool, unique_id: str, prev_replica: Replica, next_replica: Replica, key: instance, keychain: dict, client: instance):
        self.unique_id = unique_id
        self.running_state = {}
        self.history = []
        self.result_proof = []
        self.order_proof = []

        self.mode = REPLICA_ACTIVE
        self.prev_replica = prev_replica
        self.next_replica = next_replica
        self.public_keys = {}
        self.private_key = None
        self.result_shuttle_cache = {}
        self.checkpoint_proof_cache = {}
        self.isHead = isHead
        self.isTail = isTail
        self.current_slot = 0
        self.config_number = 1
        self.retransmission = []
        self.waiting_for_result_shuttle = {}
        self.passport = key
        self.operations_dispatcher = {
            'put' : self._put,
            'append': self._append,
            'slice' : self._slice,
            'get' :self._get
        }
        _build_key_chain(keychain)
        self.client = client


    def _build_key_chain(keychain):
        for replica_id, public_key in keychain.items():
            self.public_keys[replica_id] = RSA.importKey(public_key)

    '''
        Dictionary Operations

    '''

    def _put(params):
        key = params['key']
        value = params['value']
        self.running_state[key] = value


    def _append(params):
        key = params['key']
        new_value = params['value']
        if key in self.running_state:
            early_value = self.running_state[key]
            self.running_state[key] = early_value + new_value


    def _get(key):
        if key in self.running_state:
            return self.running_state[key]
        return None


    def _slice(params):
        key = params['key']
        value = params['value']
        if key in self.running_state:
            start, end = map(int, value.split(':'))
            early_value = self.running_state[key]
            self.running_state[key] = early_value[start: end]


    def run():
        #test_dict_object()
        #if self.isHead:
        #    operation =  {}
        #    operation['opr'] = 'put'
        #    operation['payload'] = {}
        #    operation['payload']['key'] = 'movie'
        #    operation['payload']['value'] = 'Bangalore Days'
        #    client_id = 1
        #    client_request_id = 1
        #    client_info = (client_id, client_request_id)
        #    handle_operation(operation, client_info)
        await(False)


    def update_current_slot_number():
        self.current_slot += 1


    def compute_running_state_hash():
        running_state_json = json.dumps(self.running_state).encode('utf-8')
        return SHA256.new(running_state_json).hexdigest()


    def generate_result_statement(result_hash):
        statement = ('result', result_hash)
        return statement


    def sign_result_statement(result_statement):
        result_stm = json.dumps(result_statement).encode('utf-8')
        result_statement_hash = SHA256.new(result_stm).digest()
        signature = self.passport.sign(result_statement_hash, '')
        return (signature, result_statement, self.unique_id)


    def add_to_result_proof(signed_result_proof):
        self.result_proof = []
        self.result_proof.append(signed_result_proof)


    def generate_order_statement(slot, operation):
        order_statement = ('order', slot, operation)
        return order_statement


    def sign_order_statement(order_statement):
        order_stm = json.dumps(order_statement).encode('utf-8')
        order_statement_hash = SHA256.new(order_stm).digest()
        signature = self.passport.sign(order_statement_hash, '')
        return (signature, order_statement, self.unique_id)


    def add_to_order_proof(signed_order_statement):
        self.order_proof = []  # TODO: Added this new
        self.order_proof.append(signed_order_statement)


    def generate_history_statement(slot, operation, order_proof):  # TODO
        history_statement = json.dumps((slot, operation, order_proof))
        return history_statement


    def add_to_history(history_statement):
        self.history.append(history_statement)


    def perform_operation(operation):
        '''
            opr: put/get/append/slice
            payload: {
                key, value
            }
        '''
        opr = operation['opr']
        payload = operation['payload']
        if opr == 'put' or opr =='append' or opr == 'slice':
            self.operations_dispatcher[opr](payload)
        elif opr == 'get':
            pass # TODO: handle get


    def handle_operation(operation, client_info):
        if self.isHead:
            update_current_slot_number()
            perform_operation(operation)
            generate_result_proof()
            generate_order_proof(operation)
            update_history(self.current_slot, operation, self.order_proof)
            client_info_checksum = SHA256.new(json.dumps(client_info).encode('utf-8')).hexdigest()
            wait_for_result_shuttle(client_info_checksum)
            shuttle_msg = generate_shuttle_message(self.result_proof, self.order_proof, self.current_slot, operation, client_info_checksum)
            dispatch_shuttle_message(shuttle_msg)


    def generate_result_proof():
        #_put(('movie', 'Bangalore Days'))
        result_hash = compute_running_state_hash()
        result_statement = generate_result_statement(result_hash)
        signed_result_statement = sign_result_statement(result_statement)
        add_to_result_proof(signed_result_statement)


    def generate_order_proof(operation):
        slot = self.current_slot
        #operation = 'put(\'movie\':\'Bangalore Days\')'
        order_statement = generate_order_statement(slot, operation)
        signed_order_statement = sign_order_statement(order_statement)
        add_to_order_proof(signed_order_statement)


    def update_history(slot, operation, order_proof):
        history_statement = generate_history_statement(slot, operation, order_proof)  # TODO: add replica_id and config number
        add_to_history(history_statement)


    def wait_for_result_shuttle(checksum):
        waiting_for_result_shuttle[checksum] = True


    def dispatch_shuttle_message(shuttle_message):
        print(self, 'sending shuttle message to ', next_replica)
        send((SHUTTLE, shuttle_message), to=next_replica)
        await(False) #  TODO: This needs to wait till it receives a complete result proof from its next replica


    def check_order_proof_validity(order_proof_list):
        slot = None
        operation = None
        for order_statement in order_proof_list:
            signature, statement, replica_id = order_statement
            _, statement_slot, statement_operation = statement
            statement_hash = SHA256.new(json.dumps(statement).encode('utf-8')).digest()
            public_key = self.public_keys[replica_id]
            if(public_key.verify(statement_hash, signature)):
                if slot is None:
                    _, slot, operation = statement
                else:
                    if slot != statement_slot or operation != statement_operation:
                        return False
            else:
                print('it messed up big')

        return True


    def populate_order_proof(order_proof_list):
        for order_statement in order_proof_list:
            self.order_proof.append(order_statement)


    def populate_result_proof(result_proof_list):
        for result_statement in result_proof_list:
            self.result_proof.append(result_statement)


    def check_result_proof_validity(result_proof_list):
        #print(self, result_proof_list)
        hashed_running_state = compute_running_state_hash()
        for result_statement in result_proof_list:
            signature, statement, replica_id = result_statement
            _, result_hash = statement
            hashed_statement = SHA256.new(json.dumps(statement).encode('utf-8')).digest()  # for validating if the correct sender has sent the message 
            public_key = self.public_keys[replica_id]
            if public_key.verify(hashed_statement, signature):
                if hashed_running_state != result_hash:
                    return False
            else:
                return False  # wrong sender
        return True


    def receive(msg=('please_work', client_payload), from_=c):
        operation = {}
        operation['client_id'] = client_payload['client_id']
        operation['request_id'] = client_payload['request_number']
        operation['opr'] = client_payload['opr']
        operation['payload'] = {}
        operation['payload']['key'] = client_payload['payload']['key']
        operation['payload']['value'] = client_payload['payload']['value']
        client_info = (operation['client_id'], operation['request_id'])
        handle_operation(operation, client_info)


    def receive(msg=('shuttle', payload), from_=prev_replica):
        shuttle_msg = payload
        #print(shuttle_msg)
        if self.current_slot+1 == shuttle_msg[SHUTTLE_SLOT]:  # new slot
            order_proof_shuttle = shuttle_msg[SHUTTLE_ORDER_PROOF]
            order_proof_is_valid = check_order_proof_validity(order_proof_shuttle)
            if order_proof_is_valid:
                operation = shuttle_msg[SHUTTLE_OPERATION]
                update_current_slot_number()
                perform_operation(operation)
                result_proof_shuttle = shuttle_msg[SHUTTLE_RESULT_PROOF]
                if check_result_proof_validity(result_proof_shuttle):
                    generate_order_proof(operation)
                    populate_order_proof(order_proof_shuttle)
                    generate_result_proof()
                    populate_result_proof(result_proof_shuttle)
                    update_history(self.current_slot, operation, self.order_proof)
                    checksum = shuttle_msg[CHECKSUM]
                    wait_for_result_shuttle(checksum)
                    shuttle_msg = generate_shuttle_message(self.result_proof, self.order_proof, self.current_slot, operation, checksum)
                    if self.isTail:
                        result_shuttle_msg = shuttle_msg
                        result_shuttle_msg[RESULT] = self.running_state
                        # Send message back to client
                        print('sending result msg to ', client)
                        #send(('result', (self.running_state, self.result_proof)), to=client)
                        print('It arrived at tail', self.running_state)
                        send(('result_shuttle', result_shuttle_msg), to=prev_replica)
                    else:
                        dispatch_shuttle_message(shuttle_msg)
                else:
                    self.mode = REPLICA_IMMUTABLE
            else:
                self.mode = REPLICA_IMMUTABLE
        else:
            self.mode = REPLICA_IMMUTABLE


    def validate_complete_result_shuttle(complete_result_proof):
        #print(complete_result_proof)
        result_digest = None
        for result_statement in complete_result_proof:
            signature, statement, replica_id = result_statement
            _, result_hash = statement
            if result_digest is None:
                result_digest = result_hash
            hashed_statement = SHA256.new(json.dumps(statement).encode('utf-8')).digest()  # for validating if the correct sender has sent the message 
            public_key = self.public_keys[replica_id]
            if public_key.verify(hashed_statement, signature):
                if result_digest != result_hash:
                    return False
        return True


    def receive(msg=('result_shuttle', payload), from_=next_replica):
        print(self, ': Receiving result shuttle')
        complete_result_proof = payload[SHUTTLE_RESULT_PROOF]
        if validate_complete_result_shuttle(complete_result_proof):
            result_shuttle = payload
            checksum = result_shuttle[CHECKSUM]
            self.result_shuttle_cache[checksum] = result_shuttle  # used during retransmission scenario
            del self.waiting_for_result_shuttle[checksum]

            if checksum in self.retransmission:
                self.retransmission.remove(checksum)
                # TODO: stop the timer
                client_result_message = generate_client_result_message(result_shuttle)
                # send this message to the client
                print('Client receives this message on retrasnmission ', client_result_message)
            if not isHead:
                send(('result_shuttle', result_shuttle), to=prev_replica)
            elif isHead:
                print('Received the complete result_shuttle ')


    def receive(msg=('retransmission', retrans_payload), from_=c):
        print('Received retransmission request from client')
        client_info = (retrans_payload['client_id'], retrans_payload['request_number'])
        checksum = SHA256.new(json.dumps(client_info).encode('utf-8')).hexdigest()

        if checksum not in self.retransmission:
            self.retransmission.append(checksum)

        if self.mode == REPLICA_IMMUTABLE:
            send(('error', ), to=c)  # TODO: Problem at the client side
        elif checksum in self.result_shuttle_cache:
            proof = self.result_shuttle_cache[checksum][SHUTTLE_RESULT_PROOF]
            res = self.result_shuttle_cache[checksum][RESULT]
            send(('result', (res, proof)), to=c)
        else:  # TODO: This part is completely messed up.. especially about cancelling timers
            if not isHead:
                send(('retransmission', retrans_payload), to=prev_replica)
                if await(some(received(('result_shuttle', payload)))):
                    pass
                elif timeout(30):
                    print('Have to send reconfigure message to Olympus')
            else:
                if not self.waiting_for_result_shuttle[checksum]:
                    # We have create a new slot and perform fresh new operation
                    pass



    def generate_client_result_message(result_shuttle):
        complete_result_proof = result_shuttle[SHUTTLE_RESULT_PROOF]
        final_result = result_shuttle[RESULT]
        return json.dumps((final_result, complete_result_proof)).encode('utf-8')


    def generate_shuttle_message(result_proof, order_proof, slot, operation, checksum):
        shuttle_msg = {}
        shuttle_msg[SHUTTLE_RESULT_PROOF] = result_proof
        shuttle_msg[SHUTTLE_ORDER_PROOF] = order_proof
        shuttle_msg[SHUTTLE_SLOT] = slot
        shuttle_msg[SHUTTLE_OPERATION] = operation
        shuttle_msg[CHECKSUM] = checksum
        shuttle_msg[CLIENT_ID] = 23
        return shuttle_msg


    def test_dict_object():
        _put(('movie', 'star'))
        _append(('movie', ' wars'))
        _get('movie')
        _slice(('movie', '0:2'))
        print(self.running_state)


def main():
    config(clock='Lamport')
    random_generator = Random.new().read

    replica1 = new(Replica, num=1)
    replica2 = new(Replica, num=1)
    replica3 = new(Replica, num=1)
    replica4 = new(Replica, num=1)

    key1 = RSA.generate(1024, random_generator)
    key2 = RSA.generate(1024, random_generator)
    key3 = RSA.generate(1024, random_generator)
    key4 = RSA.generate(1024, random_generator)

    unique_id_1 = uuid.uuid4().hex
    unique_id_2 = uuid.uuid4().hex
    unique_id_3 = uuid.uuid4().hex
    unique_id_4 = uuid.uuid4().hex


    keychain1 = {unique_id_2: key2.publickey().exportKey(), unique_id_3: key3.publickey().exportKey(), unique_id_4: key4.publickey().exportKey(), unique_id_1: key1.publickey().exportKey()}
    keychain2 = {unique_id_1: key1.publickey().exportKey(), unique_id_3: key3.publickey().exportKey(), unique_id_4: key4.publickey().exportKey(), unique_id_2: key2.publickey().exportKey()}
    keychain3 = {unique_id_1: key1.publickey().exportKey(), unique_id_2: key2.publickey().exportKey(), unique_id_4: key4.publickey().exportKey(), unique_id_3: key3.publickey().exportKey()}
    keychain4 = {unique_id_1: key1.publickey().exportKey(), unique_id_2: key2.publickey().exportKey(), unique_id_3: key3.publickey().exportKey(), unique_id_4: key4.publickey().exportKey()}


    setup(replica1, (True, False, unique_id_1, None, replica2, key1, keychain1, None))
    setup(replica2, (False, False, unique_id_2, replica1, replica3, key2, keychain2, None))
    setup(replica3, (False, False, unique_id_3, replica2, replica4, key3, keychain3, None))
    setup(replica4, (False, True, unique_id_4, replica3, None, key4, keychain4, None))


    start(replica1)
    start(replica2)
    start(replica3)
    start(replica4)
